# ================================================================
# BGScript demo application: GPIO interrupts
# Jeff Rowberg <jeff.rowberg@bluegiga.com>
# ----------------------------------------------------------------
#
# CHANGELOG:
#   2013-04-16 - Fix missing P1 data storage
#   2013-01-10 - Initial release
#
# ================================================================

const PIN_SELECT_MASK = $0F         # 0b00001111 = Px_0-Px_3 are inputs

dim connected       # BLE connection status
dim advertising     # advertising status (0=off, 1=on)
dim io_status(4)    # port status characteristic local uint8array container
dim ipr_result      # container for io_port_read() call's returned "result" value (uint16)
dim ipr_port        # container for io_port_read() call's returned "port" value (uint8)
dim ipr_data        # container for io_port_read() call's returned "port" value (uint8)
dim port0_delta(4)  # debounce comparison variable
dim port1_delta(4)  # debounce comparison variable
dim irq_pos         # convert irq from bitvector to single number
dim holding_irq     # currently holding a button for a mode change
dim last_sent_state(2) # snapshot of last sent state, to avoid repeats
dim bat_pct         # battery percentage
dim batconn_handle  # battery connection
dim last_bat_pct    # cache of last battery % seen

event system_boot(major, minor, patch, build, ll_version, protocol, hw)
    # initialize connection status as DISCONNECTED
    connected = 0
    
    # initialize advertising status as ON (since we're about to turn it on)
    advertising = 1

    # initialize simple GPIO debouncing test var to 0 (first press will be accepted)
    port0_delta(0:4) = 0
    port1_delta(0:4) = 0
    last_sent_state(0:2) = 0
    irq_pos = 0
    holding_irq = $ff
    
    # initialize battery level
    last_bat_pct = 0
    
    # set advertisement interval to 200-300ms, and use all advertisement channels
    # (note min/max parameters are in units of 625 uSec)
    call gap_set_adv_parameters(640, 960, 1)

    # put module into discoverable/connectable mode
    call gap_set_mode(gap_general_discoverable, gap_undirected_connectable)
    
    # # enable interrupt on P0_X rising edge
    # # (parameters are port=0, bitmask=0b00000011, edge=rising)
    call hardware_io_port_config_irq(0, PIN_SELECT_MASK, 0)
    # # enable interrupt on P1_X falling edge
    # # (parameters are port=1, bitmask=0b01000000, edge=falling)
    call hardware_io_port_config_irq(1, PIN_SELECT_MASK, 1)
    
    # enable falling-edge interrupts on Port0 pins
    call hardware_io_port_config_pull(0, $00, 0)
    call hardware_io_port_irq_enable(0, PIN_SELECT_MASK)
    call hardware_io_port_irq_direction(0, 1)

    # enable rising-edge interrupts on Port1 pins
    # (dual-pin connections allows CHANGE-style interrupts)
    call hardware_io_port_config_pull(1, $00, 0)
    call hardware_io_port_irq_enable(1, PIN_SELECT_MASK)
    call hardware_io_port_irq_direction(1, 0)
    
    # DEVKIT UART OUTPUT: welcome message
    call system_endpoint_tx(system_endpoint_uart1, 28, "\r\n========================\r\n")
    call system_endpoint_tx(system_endpoint_uart1, 28, "Turn Touch Mac Remote Bootup\r\n")
end

event connection_status(connection, flags, address, address_type, conn_interval, timeout, latency, bonding)
    # check for "new connection established" event
    if (flags & $05) = $05 then
        # set connection status to CONNECTED
        connected = 1

        # DEVKIT UART OUTPUT: connected
        call system_endpoint_tx(system_endpoint_uart1, 11, "CONNECTED\r\n")
    end if
    
    # check for "encrypted" status (e.g. connected + bonded, not used by this IRQ demo)
    if (flags & $02) = $02 then
        # DEVKIT UART OUTPUT: connected
        call system_endpoint_tx(system_endpoint_uart1, 11, "ENCRYPTED\r\n")
    end if
end

event connection_disconnected(handle, result)
    # set connection status to DISCONNECTED
    connected = 0
    
    # DEVKIT UART OUTPUT: disconnected
    call system_endpoint_tx(system_endpoint_uart1, 14, "DISCONNECTED\r\n")

    # set advertisement interval back to 200-300ms, use all advertisement channels
    # (note min/max parameters are in units of 625 uSec)
    call gap_set_adv_parameters(640, 960, 1)

    # put module back into discoverable/connectable mode
    # (also resumes advertising based on parameters)
    call gap_set_mode(gap_general_discoverable, gap_undirected_connectable)
end

# catch button press for P0_0, P0_1, P1_6 (active HIGH configuration, hardware.xml pulls it low)
event hardware_io_port_status(delta, port, irq, state)
    # reject this press if it's less then 100ms after the last one (32768 = 1 sec)
    if (irq & 1) = 1 then
        irq_pos = $00
    end if
    if (irq & 2) = 2 then
        irq_pos = $01
    end if
    if (irq & 4) = 4 then
        irq_pos = $02
    end if
    if (irq & 8) = 8 then
        irq_pos = $03
    end if
    if port = 0 then
        if delta - port0_delta(irq_pos:1) < 6554 then
            return # 100ms debounce
        end if
    end if
    if port = 1 then
        if delta - port1_delta(irq_pos:1) < 6554 then
            return # 100ms debounce
        end if
    end if
    
    # start mode change timer
    call hardware_set_soft_timer(0, 0, 1)
    if port = 1 then
        call hardware_set_soft_timer(19660, 0, 1) # 500ms
    end if
    if port = 0 then
        port0_delta(irq_pos:1) = delta
    end if
    if port = 1 then
        port1_delta(irq_pos:1) = delta
    end if
    
    if port = 0 then       
        # store state of Port 0 now, since we already have it
        io_status(0:1) = state & $0f
        
        # read state of Port 1
        call hardware_io_port_read(1, $ff)(ipr_result, ipr_port, ipr_data)
        io_status(3:1) = ipr_data & $0f
    end if
    if port = 1 then
        # read state of Port 0
        call hardware_io_port_read(0, $ff)(ipr_result, ipr_port, ipr_data)
        io_status(0:1) = ipr_data & $0f

        # store state of Port 1 now, since we already have it
        io_status(3:1) = state & $0f
    end if
    
    # Add port and irq to message for debugging
    io_status(0:1) = io_status(0:1) & io_status(3:1)
    io_status(3:1) = io_status(0:1)
    io_status(1:1) = port # unreliable, as rising/falling edge may be called
    io_status(2:1) = irq
    
    # update characteristic value (will push data if client has subscribed to notifications/indications)
    if last_sent_state(0:1) != io_status(0:1) then
        last_sent_state(0:1) = io_status(0:1)
        call attributes_write(c_gpio_status, 0, 3, io_status(0:3))
    end if
    
    # Nothing left to do but sleep
    if connected then
        call hardware_adc_read($f,1,0)
    
        call system_endpoint_tx(system_endpoint_uart1, 13, "Sleeping...\r\n")
        call gap_set_mode(0, 0)
    else
        call hardware_adc_read($f,1,0)
        
        call system_endpoint_tx(system_endpoint_uart1, 13, "Scanning...\r\n")
        call gap_set_mode(gap_general_discoverable, gap_undirected_connectable)
    end if
end

# Mode change timer
event hardware_soft_timer(handle)
    # read state of Port 0
    call hardware_io_port_read(0, $ff)(ipr_result, ipr_port, ipr_data)
    io_status(0:1) = ipr_data & $0f
    
    io_status(1:2) = $ffff
    if last_sent_state(0:1) = io_status(0:1) && io_status(0:1) != 0 then
        call system_endpoint_tx(system_endpoint_uart1, 13, "Mode change!\r\n")
        call attributes_write(c_gpio_status, 0, 3, io_status(0:3))
    end if
end

# This event listener listens for incoming ATT protocol read requests, and when the battery
# attribute is read, executes an ADC read and sends back the computer result when complete.
event attributes_user_read_request(connection, handle, offset, maxsize)
    # Store current connection handle for later
    batconn_handle = connection
    # Request ADC read operation
    #   15 = AVDD/3 channel (will be between 0.66v - 1.2v by definition)
    #   3 = 12 effective bits, range = [-2048, +2047] when right-aligned
    #   0 = internal 1.24V reference
    call hardware_adc_read($f, 1, 0)
end

# This event listener catches the ADC result
event hardware_adc_result(input, value)
    # ADC behavior:
    # - Range is [-2048, +2047] when 12 ENOB is selected
    # - Value will be left-aligned in a 16-bit container, meaning the direct
    #       result will be in the range [-32768, +32767] and must be shifted
    # - Actual battery readings will only ever be positive, so we only care
    #       about the positive part of the range [0, +32767] or 0x0000-0x7FFF
    # - VDD voltage = (value >> 4) * 3 * 1.24 / 2048
    # *** IMPORTANT***
    # A new CR2032 battery reads at ~2.52v based on some tests, but different
    # batteries may exhibit different levels here depending on chemistry.
    # You should test the range with your own battery to make sure).
    # - A "full" battery will read ~2.5v:
    #   --> (3.0v/3) * (32767/1.24v) = 26425
    # - An "empty" battery will read ~2.0v (min module voltage):
    #   --> (2.0v/3) * (32767/1.24v) = 17616
    # This means we must scale [+17616, +23342] to [0, +100]
    bat_pct = (value - 17616) * 100 / (26425 - 17616)
    
    # Only update battery level if it has dropped
    # >= only for testing, change to >
    if last_bat_pct = 0 || last_bat_pct >= bat_pct || last_bat_pct < bat_pct
        last_bat_pct = bat_pct
        call attributes_write(c_battery_level, 0, 1, bat_pct)
    end if
        
    # respond with calculated percent (connection=stored value, result=0, length=1, data=bat_pct)
    call attributes_user_read_response(batconn_handle, 0, 1, bat_pct)
end