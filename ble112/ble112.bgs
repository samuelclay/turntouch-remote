# ================================================================
# BGScript demo application: GPIO interrupts
# Jeff Rowberg <jeff.rowberg@bluegiga.com>
# ----------------------------------------------------------------
#
# CHANGELOG:
#   2013-04-16 - Fix missing P1 data storage
#   2013-01-10 - Initial release
#
# ================================================================

const PIN_SELECT_MASK = $0F         # 0b11111111 = Px_0-Px_7 are outputs

dim connected       # BLE connection status
dim advertising     # advertising status (0=off, 1=on)
dim io_status(4)    # port status characteristic local uint8array container
dim ipr_result      # container for io_port_read() call's returned "result" value (uint16)
dim ipr_port        # container for io_port_read() call's returned "port" value (uint8)
dim ipr_data        # container for io_port_read() call's returned "port" value (uint8)
dim port0_delta(4)  # debounce comparison variable
dim port1_delta(4)  # debounce comparison variable
dim irq_pos         # convert irq from bitvector to single number
dim holding_irq     # currently holding a button for a mode change
dim last_sent_state(2) # snapshot of last sent state, to avoid repeats

event system_boot(major, minor, patch, build, ll_version, protocol, hw)
    # initialize connection status as DISCONNECTED
    connected = 0
    
    # initialize advertising status as ON (since we're about to turn it on)
    advertising = 1

    # initialize simple GPIO debouncing test var to 0 (first press will be accepted)
    port0_delta(0:4) = 0
    port1_delta(0:4) = 0
    last_sent_state(0:2) = 0
    irq_pos = 0
    holding_irq = $ff
    
    # set advertisement interval to 200-300ms, and use all advertisement channels
    # (note min/max parameters are in units of 625 uSec)
    call gap_set_adv_parameters(320, 480, 7)

    # put module into discoverable/connectable mode
    call gap_set_mode(gap_general_discoverable, gap_undirected_connectable)
    
    # # enable interrupt on P0_X rising edge
    # # (parameters are port=0, bitmask=0b00000011, edge=rising)
    call hardware_io_port_config_irq(0, PIN_SELECT_MASK, 0)
    # # enable interrupt on P1_X falling edge
    # # (parameters are port=1, bitmask=0b01000000, edge=falling)
    call hardware_io_port_config_irq(1, PIN_SELECT_MASK, 1)
    
    # enable falling-edge interrupts on Port0 pins
    call hardware_io_port_config_pull(0, $00, 0)
    call hardware_io_port_irq_enable(0, PIN_SELECT_MASK)
    call hardware_io_port_irq_direction(0, 1)

    # enable rising-edge interrupts on Port1 pins
    # (dual-pin connections allows CHANGE-style interrupts)
    call hardware_io_port_config_pull(1, $00, 0)
    call hardware_io_port_irq_enable(1, PIN_SELECT_MASK)
    call hardware_io_port_irq_direction(1, 0)
    
    # DEVKIT UART OUTPUT: welcome message
    call system_endpoint_tx(system_endpoint_uart1, 28, "\r\n========================\r\n")
    call system_endpoint_tx(system_endpoint_uart1, 28, "Turn Touch Mac Remote Bootup\r\n")
end

event connection_status(connection, flags, address, address_type, conn_interval, timeout, latency, bonding)
    # check for "new connection established" event
    if (flags & $05) = $05 then
        # set connection status to CONNECTED
        connected = 1

        # DEVKIT UART OUTPUT: connected
        call system_endpoint_tx(system_endpoint_uart1, 11, "CONNECTED\r\n")
    end if
    
    # check for "encrypted" status (e.g. connected + bonded, not used by this IRQ demo)
    if (flags & $02) = $02 then
        # DEVKIT UART OUTPUT: connected
        call system_endpoint_tx(system_endpoint_uart1, 11, "ENCRYPTED\r\n")
    end if
end

event connection_disconnected(handle, result)
    # set connection status to DISCONNECTED
    connected = 0
    
    # DEVKIT UART OUTPUT: disconnected
    call system_endpoint_tx(system_endpoint_uart1, 14, "DISCONNECTED\r\n")

    # set advertisement interval back to 200-300ms, use all advertisement channels
    # (note min/max parameters are in units of 625 uSec)
    call gap_set_adv_parameters(320, 480, 7)

    # put module back into discoverable/connectable mode
    # (also resumes advertising based on parameters)
    call gap_set_mode(gap_general_discoverable, gap_undirected_connectable)
end

# catch button press for P0_0, P0_1, P1_6 (active HIGH configuration, hardware.xml pulls it low)
event hardware_io_port_status(delta, port, irq, state)
    # reject this press if it's less then 100ms after the last one (32768 = 1 sec)
    if (irq & 1) = 1 then
        irq_pos = $00
    end if
    if (irq & 2) = 2 then
        irq_pos = $01
    end if
    if (irq & 4) = 4 then
        irq_pos = $02
    end if
    if (irq & 8) = 8 then
        irq_pos = $03
    end if
    if port = 0 then
        if delta - port0_delta(irq_pos:1) < 6554 then
            return
        end if
    end if
    if port = 1 then
        if delta - port1_delta(irq_pos:1) < 6554 then
            return
        end if
    end if
    
    # start mode change timer
    call hardware_set_soft_timer(0, 0, 1)
    if port = 1 then
        call hardware_set_soft_timer(19660, 0, 1)
    end if
    if port = 0 then
        port0_delta(irq_pos:1) = delta
    end if
    if port = 1 then
        port1_delta(irq_pos:1) = delta
    end if
    
    if port = 0 then       
        # store state of Port 0 now, since we already have it
        io_status(0:1) = state & $0f
        
        # read state of Port 1
        call hardware_io_port_read(1, $ff)(ipr_result, ipr_port, ipr_data)
        io_status(3:1) = ipr_data & $0f
    end if
    if port = 1 then
        # read state of Port 0
        call hardware_io_port_read(0, $ff)(ipr_result, ipr_port, ipr_data)
        io_status(0:1) = ipr_data & $0f

        # store state of Port 1 now, since we already have it
        io_status(3:1) = state & $0f
    end if
    
    # Add port and irq to message for debugging
    io_status(0:1) = io_status(0:1) & io_status(3:1)
    io_status(3:1) = io_status(0:1)
    io_status(1:1) = port
    io_status(2:1) = irq
    
    # update characteristic value (will push data if client has subscribed to notifications/indications)
    if last_sent_state(0:1) != io_status(0:1) then
        last_sent_state(0:1) = io_status(0:1)
        call attributes_write(c_gpio_status, 0, 3, io_status(0:3))
    end if
    
    # Nothing left to do but sleep
    if connected then
        call gap_set_mode(0, 0)
    else
        call gap_set_mode(gap_general_discoverable, gap_undirected_connectable)
    end if
end

# Mode change timer
event hardware_soft_timer(handle)
    # read state of Port 0
    call hardware_io_port_read(0, $ff)(ipr_result, ipr_port, ipr_data)
    io_status(0:1) = ipr_data & $0f
    
    io_status(1:2) = $ffff
    if last_sent_state(0:1) = io_status(0:1) && io_status(0:1) != 0 then
        call attributes_write(c_gpio_status, 0, 3, io_status(0:3))
    end if
end
