# ================================================================
# BGScript demo application: GPIO interrupts
# Jeff Rowberg <jeff.rowberg@bluegiga.com>
# ----------------------------------------------------------------
#
# CHANGELOG:
#   2013-04-16 - Fix missing P1 data storage
#   2013-01-10 - Initial release
#
# ================================================================

const PORT0_PIN_SELECT_MASK = $C3         # 0b11000011 = P0_0-P0_1 & P0_6-P0_7 are inputs
const PORT1_PIN_SELECT_MASK = $78         # 0b01110000 = Px_3-Px_6 are inputs

dim connected       # BLE connection status
dim advertising     # advertising status (0=off, 1=on)
dim io_status(4)    # port status characteristic local uint8array container
dim ipr_result      # container for io_port_read() call's returned "result" value (uint16)
dim ipr_port        # container for io_port_read() call's returned "port" value (uint8)
dim ipr_data        # container for io_port_read() call's returned "port" value (uint8)
dim port0_delta(4)  # debounce comparison variable
dim port1_delta(4)  # debounce comparison variable
dim irq_pos         # convert irq from bitvector to single number
dim holding_irq     # currently holding a button for a mode change
dim last_sent_state(2) # snapshot of last sent state, to avoid repeats
dim bat_pct         # battery percentage
dim batconn_handle  # battery connection
dim last_bat_pct    # cache of last battery % seen
dim t(12)

event system_boot(major, minor, patch, build, ll_version, protocol, hw)
    # initialize connection status as DISCONNECTED
    connected = 0
    
    # initialize advertising status as ON (since we're about to turn it on)
    advertising = 1

    # initialize simple GPIO debouncing test var to 0 (first press will be accepted)
    port0_delta(0:4) = 0
    port1_delta(0:4) = 0
    last_sent_state(0:2) = $0f
    irq_pos = 0
    holding_irq = $ff
    
    # initialize battery level
    last_bat_pct = 0
    
    # set all GPIO pins to input/high (pull), except P1_0 and P1_1 to output HIGH (no internal pull-ups)
    # P1_0/1 will leak current if not externally pulled or set as outputs
    call hardware_io_port_config_direction(0, $0)
    call hardware_io_port_write(0, $ff, $ff)
    call hardware_io_port_config_direction(1, $3)
    call hardware_io_port_write(1, $ff, $ff)
    call hardware_io_port_config_direction(2, $0)
    call hardware_io_port_write(2, $ff, $ff)
    
    # set advertisement interval to 200-300ms, and use all advertisement channels
    # (note min/max parameters are in units of 625 uSec)
    call gap_set_adv_parameters(1600, 3200, 7)
    # call gap_set_adv_parameters(64, 96, 1)

    # put module into discoverable/connectable mode
    call gap_set_mode(gap_general_discoverable, gap_undirected_connectable)
    
    # enable falling-edge interrupts on Port0 pins
    call hardware_io_port_config_pull(0, $00, 1)
    call hardware_io_port_irq_enable(0, PORT0_PIN_SELECT_MASK)
    call hardware_io_port_irq_direction(0, 0)

    # enable rising-edge interrupts on Port1 pins
    # (dual-pin connections allows CHANGE-style interrupts)
    call hardware_io_port_config_pull(1, $00, 1)
    call hardware_io_port_irq_enable(1, PORT1_PIN_SELECT_MASK)
    call hardware_io_port_irq_direction(1, 1)
    
    # DEVKIT UART OUTPUT: welcome message
    call system_endpoint_tx(system_endpoint_uart1, 28, "\r\n========================\r\n")
    call system_endpoint_tx(system_endpoint_uart1, 28, "Turn Touch Mac Remote Bootup\r\n")
end

event connection_status(connection, flags, address, address_type, conn_interval, timeout, latency, bonding)
    # check for "new connection established" event
    if (flags & $05) = $05 then
        # set connection status to CONNECTED
        connected = 1

        # DEVKIT UART OUTPUT: connected
        call system_endpoint_tx(system_endpoint_uart1, 11, "CONNECTED\r\n")
    end if
    
    # check for "encrypted" status (e.g. connected + bonded, not used by this IRQ demo)
    if (flags & $02) = $02 then
        # DEVKIT UART OUTPUT: connected
        call system_endpoint_tx(system_endpoint_uart1, 11, "ENCRYPTED\r\n")
    end if
end

event connection_disconnected(handle, result)
    # set connection status to DISCONNECTED
    connected = 0
    
    # DEVKIT UART OUTPUT: disconnected
    call system_endpoint_tx(system_endpoint_uart1, 14, "DISCONNECTED\r\n")

    # set advertisement interval back to 200-300ms, use all advertisement channels
    # (note min/max parameters are in units of 625 uSec)
    # call gap_set_adv_parameters(1600, 3200, 7)
    call gap_set_adv_parameters(64, 96, 1)

    # put module back into discoverable/connectable mode
    # (also resumes advertising based on parameters)
    call gap_set_mode(gap_general_discoverable, gap_undirected_connectable)
end

# catch button presses (active LOW, hardware.xml pulls it high)
event hardware_io_port_status(delta, port, irq, state)
    # normalize irq
    call system_endpoint_tx(system_endpoint_uart1, 13, "Interrupt -- ")
    t(0:1) = (irq / 100) + 48
    t(1:1) = (irq / 10) + (irq / -100 * 10) + 48
    t(2:1) = irq + (irq / 10 * -10) + 48
    call system_endpoint_tx(system_endpoint_uart1, 3, t(0:3))
    call system_endpoint_tx(system_endpoint_uart1, 4, " -- ")
    if (port = 0 && (irq & $01)) || (port = 1 && (irq & $08)) then
        call system_endpoint_tx(system_endpoint_uart1, 3, "1\r\n")
        irq_pos = 1
    end if
    if (port = 0 && (irq & $02)) then
        call system_endpoint_tx(system_endpoint_uart1, 4, "20\r\n")
        irq_pos = 2
    end if
    if (port = 1 && (irq & $10)) then
        call system_endpoint_tx(system_endpoint_uart1, 4, "21\r\n")
        irq_pos = 2
    end if
    if (port = 0 && (irq & $40)) || (port = 1 && (irq & $20)) then
        call system_endpoint_tx(system_endpoint_uart1, 3, "3\r\n")
        irq_pos = 3
    end if
    if (port = 0 && (irq & $80)) then
        call system_endpoint_tx(system_endpoint_uart1, 4, "40\r\n")
        irq_pos = 4
    end if
    if (port = 1 && (irq & $40)) then
        call system_endpoint_tx(system_endpoint_uart1, 4, "41\r\n")
        irq_pos = 4
    end if
    
    # reject this press if it's less then 100ms after the last one (32768 = 1 sec)
    if port = 0 then
        if delta - port0_delta(irq_pos:1) < 6554 then
            return # 100ms debounce
        end if
    end if
    if port = 1 then
        if delta - port1_delta(irq_pos:1) < 6554 then
            return # 100ms debounce
        end if
    end if
    
    # start mode change timer
    call hardware_set_soft_timer(0, 0, 1)
    # use falling edge port to detect button pressed
    if port = 1 then
        call hardware_set_soft_timer(23592, 0, 1) # 600ms
    end if
    if port = 0 then
        port0_delta(irq_pos:1) = delta
    end if
    if port = 1 then
        port1_delta(irq_pos:1) = delta
    end if
    
    if port = 0 then       
        # store state of Port 0 now, since we already have it
        io_status(0:1) = state & PORT0_PIN_SELECT_MASK
        
        # read state of Port 1
        call hardware_io_port_read(1, $ff)(ipr_result, ipr_port, ipr_data)
        io_status(3:1) = ipr_data & PORT1_PIN_SELECT_MASK
    end if
    if port = 1 then
        # read state of Port 0
        call hardware_io_port_read(0, $ff)(ipr_result, ipr_port, ipr_data)
        io_status(0:1) = ipr_data & PORT0_PIN_SELECT_MASK

        # store state of Port 1 now, since we already have it
        io_status(3:1) = state & PORT1_PIN_SELECT_MASK
    end if
    
    # Add port and irq to message for debugging
    io_status(0:1) = (io_status(0:1) >> 4) | (io_status(0:1) & $0F)
    io_status(1:1) = $00
    # update characteristic value (will push data if client has subscribed to notifications/indications)
    if last_sent_state(0:1) != io_status(0:1) then
        last_sent_state(0:1) = io_status(0:1)
        call attributes_write(c_gpio_status, 0, 2, io_status(0:2))
        call hardware_adc_read($0f,1,0)
    end if
    
    # Nothing left to do but sleep
    if connected then    
#        call system_endpoint_tx(system_endpoint_uart1, 13, "Sleeping...\r\n")
        call gap_set_mode(0, 0)
    else    
#        call system_endpoint_tx(system_endpoint_uart1, 13, "Scanning...\r\n")
        call gap_set_mode(gap_general_discoverable, gap_undirected_connectable)
    end if
end

# Mode change timer
event hardware_soft_timer(handle)
    # read state of Port 0
    call system_endpoint_tx(system_endpoint_uart1, 16, "Wake for timer\r\n")
    
    call hardware_io_port_read(0, $ff)(ipr_result, ipr_port, ipr_data)
    io_status(0:1) = ipr_data & PORT0_PIN_SELECT_MASK
    io_status(0:1) = (io_status(0:1) >> 4) | (io_status(0:1) & $0F)
    io_status(1:1) = $ff
    
    if last_sent_state(0:1) = io_status(0:1) && io_status(0:1) != $0f then
        call system_endpoint_tx(system_endpoint_uart1, 13, "Mode change!\r\n")
        call attributes_write(c_gpio_status, 0, 2, io_status(0:2))
    end if
end

# This event listener listens for incoming ATT protocol read requests, and when the battery
# attribute is read, executes an ADC read and sends back the computer result when complete.
event attributes_user_read_request(connection, handle, offset, maxsize)
    # Store current connection handle for later
    batconn_handle = connection
    # Request ADC read operation
    #   15 = AVDD/3 channel (will be between 0.66v - 1.2v by definition)
    #   3 = 12 effective bits, range = [-2048, +2047] when right-aligned
    #   0 = internal 1.24V reference
    call hardware_adc_read($f, 1, 0)
end

# This event listener catches the ADC result
event hardware_adc_result(input, value)
    # ADC behavior:
    # - Range is [-2048, +2047] when 12 ENOB is selected
    # - Value will be left-aligned in a 16-bit container, meaning the direct
    #       result will be in the range [-32768, +32767] and must be shifted
    # - Actual battery readings will only ever be positive, so we only care
    #       about the positive part of the range [0, +32767] or 0x0000-0x7FFF
    # - VDD voltage = (value >> 4) * 3 * 1.24 / 2048
    # *** IMPORTANT***
    # A new CR2032 battery reads at ~2.52v based on some tests, but different
    # batteries may exhibit different levels here depending on chemistry.
    # You should test the range with your own battery to make sure).
    # - A "full" battery will read ~2.5v:
    #   --> (3.0v/3) * (32767/1.24v) = 26425
    # - An "empty" battery will read ~2.0v (min module voltage):
    #   --> (2.0v/3) * (32767/1.24v) = 17616
    # This means we must scale [+17616, +23342] to [0, +100]
    bat_pct = (value - 17616) * 100 / (26425 - 17616)
    
    # Only update battery level if it has dropped
    # >= only for testing, change to >
    if last_bat_pct = 0 || last_bat_pct >= bat_pct || last_bat_pct < bat_pct
        last_bat_pct = bat_pct
        call attributes_write(c_battery_level, 0, 1, bat_pct)
    end if
        
    # respond with calculated percent (connection=stored value, result=0, length=1, data=bat_pct)
    call attributes_user_read_response(batconn_handle, 0, 1, bat_pct)
end