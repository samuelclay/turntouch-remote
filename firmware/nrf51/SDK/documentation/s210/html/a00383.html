<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>nRF51 SDK - S210 SoftDevice: ANT Application Interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="nordic_small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">nRF51 SDK - S210 SoftDevice
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>API&#160;Reference</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a00383.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">ANT Application Interface<div class="ingroups"><a class="el" href="a00382.html">ANT STACK</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>ANT Stack Application Programming Interface (API).  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:a00381"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00381.html">ANT Error Return</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00384"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00384.html">ANT Stack Parameters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga05570d07c3605d3c38e1546fc0bbd2de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga05570d07c3605d3c38e1546fc0bbd2de"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STK_SVC_BASE_2</b>&#160;&#160;&#160;0xC0</td></tr>
<tr class="separator:ga05570d07c3605d3c38e1546fc0bbd2de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gabc6126af1d45847bc59afa0aa3216b04"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br/>
&#160;&#160;<b>SVC_ANT_STACK_INIT</b> = 0xC0, 
<br/>
&#160;&#160;<b>SVC_ANT_EVENT_GET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_CHANNEL_ASSIGN</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_CHANNEL_UNASSIGN</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_CHANNEL_OPEN</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_CHANNEL_CLOSE</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_RX_SCAN_MODE_START</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_TX_BROADCAST_MESSAGE</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_TX_ACKNOWLEDGED_MESSAGE</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_BURST_HANDLER_REQUEST</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_PENDING_TRANSMIT_CLEAR</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_TRANSFER_STOP</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_NETWORK_KEY_SET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_CHANNEL_RADIO_FREQ_SET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_CHANNEL_RADIO_FREQ_GET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_CHANNEL_RADIO_TX_POWER_SET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_PROX_SEARCH_SET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_CHANNEL_PERIOD_SET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_CHANNEL_PERIOD_GET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_CHANNEL_ID_SET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_CHANNEL_ID_GET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_SEARCH_WAVEFORM_SET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_CHANNEL_RX_SEARCH_TIMEOUT_SET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_SEARCH_CHANNEL_PRIORITY_SET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_ACTIVE_SEARCH_SHARING_CYCLES_SET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_ACTIVE_SEARCH_SHARING_CYCLES_GET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_CHANNEL_LOW_PRIO_RX_SEARCH_TIMEOUT_SET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_ADV_BURST_CONFIG_SET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_ADV_BURST_CONFIG_GET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_LIB_CONFIG_SET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_LIB_CONFIG_CLEAR</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_LIB_CONFIG_GET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_ID_LIST_ADD</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_ID_LIST_CONFIG</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_AUTO_FREQ_HOP_TABLE_SET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_EVENT_FILTERING_SET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_EVENT_FILTERING_GET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_ACTIVE</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_CHANNEL_IN_PROGRESS</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_CHANNEL_STATUS_GET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_PENDING_TRANSMIT</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_INIT_CW_TEST_MODE</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_CW_TEST_MODE</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_VERSION</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_CAPABILITIES</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_BURST_HANDLER_WAIT_FLAG_ENABLE</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_BURST_HANDLER_WAIT_FLAG_DISABLE</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_SDU_MASK_SET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_SDU_MASK_GET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_SDU_MASK_CONFIG</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_CRYPTO_CHANNEL_ENABLE</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_CRYPTO_KEY_SET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_CRYPTO_INFO_SET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_CRYPTO_INFO_GET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_RFACTIVE_NOTIFICATION_CONFIG_SET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_RFACTIVE_NOTIFICATION_CONFIG_GET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_COEX_CONFIG_SET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_COEX_CONFIG_GET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_RESERVED0</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_RESERVED1</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_RESERVED2</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_EXTENDED0</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_EXTENDED1</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_EXTENDED2</b>
<br/>
 }</td></tr>
<tr class="memdesc:gabc6126af1d45847bc59afa0aa3216b04"><td class="mdescLeft">&#160;</td><td class="mdescRight">ANT Stack API SVC numbers. <br/></td></tr>
<tr class="separator:gabc6126af1d45847bc59afa0aa3216b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
ANT API functions</h2></td></tr>
<tr class="memitem:ga38b44d71b463cfd0d12fa07b63191d9f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#ga38b44d71b463cfd0d12fa07b63191d9f">sd_ant_stack_reset</a> (void)</td></tr>
<tr class="memdesc:ga38b44d71b463cfd0d12fa07b63191d9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for initializing or re-initializing ANT Stack.  <a href="#ga38b44d71b463cfd0d12fa07b63191d9f">More...</a><br/></td></tr>
<tr class="separator:ga38b44d71b463cfd0d12fa07b63191d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga871ce84112f0aa7dc40468a7d6b3fdbd"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#ga871ce84112f0aa7dc40468a7d6b3fdbd">sd_ant_event_get</a> (uint8_t *pucChannel, uint8_t *pucEvent, uint8_t *aucANTMesg)</td></tr>
<tr class="memdesc:ga871ce84112f0aa7dc40468a7d6b3fdbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns ANT channel events and data messages.  <a href="#ga871ce84112f0aa7dc40468a7d6b3fdbd">More...</a><br/></td></tr>
<tr class="separator:ga871ce84112f0aa7dc40468a7d6b3fdbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ee008ec03098a855dd200c9cec28854"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#ga0ee008ec03098a855dd200c9cec28854">sd_ant_channel_assign</a> (uint8_t ucChannel, uint8_t ucChannelType, uint8_t ucNetwork, uint8_t ucExtAssign)</td></tr>
<tr class="memdesc:ga0ee008ec03098a855dd200c9cec28854"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function assigns and initializes a new channel.  <a href="#ga0ee008ec03098a855dd200c9cec28854">More...</a><br/></td></tr>
<tr class="separator:ga0ee008ec03098a855dd200c9cec28854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe35f6cb447e86746361f1411953c171"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#gafe35f6cb447e86746361f1411953c171">sd_ant_channel_unassign</a> (uint8_t ucChannel)</td></tr>
<tr class="memdesc:gafe35f6cb447e86746361f1411953c171"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function unassigns a channel. The channel to unassign must be in an assigned state.  <a href="#gafe35f6cb447e86746361f1411953c171">More...</a><br/></td></tr>
<tr class="separator:gafe35f6cb447e86746361f1411953c171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae47817e299d072bc4c9b1c75123a20e6"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#gae47817e299d072bc4c9b1c75123a20e6">sd_ant_channel_open</a> (uint8_t ucChannel)</td></tr>
<tr class="memdesc:gae47817e299d072bc4c9b1c75123a20e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function opens and activates a channel. The channel to open must be in an assigned state.  <a href="#gae47817e299d072bc4c9b1c75123a20e6">More...</a><br/></td></tr>
<tr class="separator:gae47817e299d072bc4c9b1c75123a20e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6b069b1d3147d0bcac9505efa60dea6"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#gad6b069b1d3147d0bcac9505efa60dea6">sd_ant_channel_close</a> (uint8_t ucChannel)</td></tr>
<tr class="memdesc:gad6b069b1d3147d0bcac9505efa60dea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function closes a channel. The channel must be in an open state (SEARCHING or TRACKING).  <a href="#gad6b069b1d3147d0bcac9505efa60dea6">More...</a><br/></td></tr>
<tr class="separator:gad6b069b1d3147d0bcac9505efa60dea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafafa38f71054778becea049bc3ada46"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#gaafafa38f71054778becea049bc3ada46">sd_ant_rx_scan_mode_start</a> (uint8_t ucSyncChannelPacketsOnly)</td></tr>
<tr class="memdesc:gaafafa38f71054778becea049bc3ada46"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function starts receive scanning mode feature. Channel 0 must be assigned. All other channels must be closed.  <a href="#gaafafa38f71054778becea049bc3ada46">More...</a><br/></td></tr>
<tr class="separator:gaafafa38f71054778becea049bc3ada46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e48883c0e50c1c380b61fd0c28b3879"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#ga2e48883c0e50c1c380b61fd0c28b3879">sd_ant_broadcast_message_tx</a> (uint8_t ucChannel, uint8_t ucSize, uint8_t *aucMesg)</td></tr>
<tr class="memdesc:ga2e48883c0e50c1c380b61fd0c28b3879"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to set broadcast data for transmission.  <a href="#ga2e48883c0e50c1c380b61fd0c28b3879">More...</a><br/></td></tr>
<tr class="separator:ga2e48883c0e50c1c380b61fd0c28b3879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga893d871362f4eaf1e82a6749af27136b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#ga893d871362f4eaf1e82a6749af27136b">sd_ant_acknowledge_message_tx</a> (uint8_t ucChannel, uint8_t ucSize, uint8_t *aucMesg)</td></tr>
<tr class="memdesc:ga893d871362f4eaf1e82a6749af27136b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to send an acknowledge message. This message requests an acknowledgement from the slave to validate reception.  <a href="#ga893d871362f4eaf1e82a6749af27136b">More...</a><br/></td></tr>
<tr class="separator:ga893d871362f4eaf1e82a6749af27136b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa09761cfc5e7373048e90e2dca208e6a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#gaa09761cfc5e7373048e90e2dca208e6a">sd_ant_burst_handler_request</a> (uint8_t ucChannel, uint16_t usSize, uint8_t *aucData, uint8_t ucBurstSegment)</td></tr>
<tr class="memdesc:gaa09761cfc5e7373048e90e2dca208e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to queue data for burst transmission. After every successful call, the input buffer is held in use by the burst handler and must not be changed.  <a href="#gaa09761cfc5e7373048e90e2dca208e6a">More...</a><br/></td></tr>
<tr class="separator:gaa09761cfc5e7373048e90e2dca208e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93a4111cc6e4b75e3b6b4d665937e625"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#ga93a4111cc6e4b75e3b6b4d665937e625">sd_ant_pending_transmit_clear</a> (uint8_t ucChannel, uint8_t *pucSuccess)</td></tr>
<tr class="memdesc:ga93a4111cc6e4b75e3b6b4d665937e625"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function clears a pending transmit. Primarily intended for shared slave channels (receive channel).  <a href="#ga93a4111cc6e4b75e3b6b4d665937e625">More...</a><br/></td></tr>
<tr class="separator:ga93a4111cc6e4b75e3b6b4d665937e625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59fb0d7717ce7e81a0adecd247511b17"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#ga59fb0d7717ce7e81a0adecd247511b17">sd_ant_transfer_stop</a> (void)</td></tr>
<tr class="memdesc:ga59fb0d7717ce7e81a0adecd247511b17"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function kills a receive transfer that is in progress.  <a href="#ga59fb0d7717ce7e81a0adecd247511b17">More...</a><br/></td></tr>
<tr class="separator:ga59fb0d7717ce7e81a0adecd247511b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga485b80f454f617a6a611dd2161330295"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#ga485b80f454f617a6a611dd2161330295">sd_ant_network_address_set</a> (uint8_t ucNetwork, uint8_t *aucNetworkKey)</td></tr>
<tr class="memdesc:ga485b80f454f617a6a611dd2161330295"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the 64bit network address.  <a href="#ga485b80f454f617a6a611dd2161330295">More...</a><br/></td></tr>
<tr class="separator:ga485b80f454f617a6a611dd2161330295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28b87b0df8a35fe5e8ffb23e7bd89967"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#ga28b87b0df8a35fe5e8ffb23e7bd89967">sd_ant_channel_radio_freq_set</a> (uint8_t ucChannel, uint8_t ucFreq)</td></tr>
<tr class="memdesc:ga28b87b0df8a35fe5e8ffb23e7bd89967"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the radio frequency of an ANT channel.  <a href="#ga28b87b0df8a35fe5e8ffb23e7bd89967">More...</a><br/></td></tr>
<tr class="separator:ga28b87b0df8a35fe5e8ffb23e7bd89967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga874e9c551db1f3297a0253c5142106bf"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#ga874e9c551db1f3297a0253c5142106bf">sd_ant_channel_radio_freq_get</a> (uint8_t ucChannel, uint8_t *pucRfreq)</td></tr>
<tr class="memdesc:ga874e9c551db1f3297a0253c5142106bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the radio frequency of an ANT channel.  <a href="#ga874e9c551db1f3297a0253c5142106bf">More...</a><br/></td></tr>
<tr class="separator:ga874e9c551db1f3297a0253c5142106bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70e472a2603eb90c0a6a8af71e764135"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#ga70e472a2603eb90c0a6a8af71e764135">sd_ant_channel_radio_tx_power_set</a> (uint8_t ucChannel, uint8_t ucTxPower, uint8_t ucCustomTxPower)</td></tr>
<tr class="memdesc:ga70e472a2603eb90c0a6a8af71e764135"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the radio tx power.  <a href="#ga70e472a2603eb90c0a6a8af71e764135">More...</a><br/></td></tr>
<tr class="separator:ga70e472a2603eb90c0a6a8af71e764135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06b245376f5a6a1b1cc3eb747b12a245"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#ga06b245376f5a6a1b1cc3eb747b12a245">sd_ant_prox_search_set</a> (uint8_t ucChannel, uint8_t ucProxThreshold, uint8_t ucCustomProxThreshold)</td></tr>
<tr class="memdesc:ga06b245376f5a6a1b1cc3eb747b12a245"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the sensitivity threshold for acquisition on a searching channel. One time set.  <a href="#ga06b245376f5a6a1b1cc3eb747b12a245">More...</a><br/></td></tr>
<tr class="separator:ga06b245376f5a6a1b1cc3eb747b12a245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f02ffc719c4589cc7943d6fb67f34e0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#ga5f02ffc719c4589cc7943d6fb67f34e0">sd_ant_channel_period_set</a> (uint8_t ucChannel, uint16_t usPeriod)</td></tr>
<tr class="memdesc:ga5f02ffc719c4589cc7943d6fb67f34e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the channel period.  <a href="#ga5f02ffc719c4589cc7943d6fb67f34e0">More...</a><br/></td></tr>
<tr class="separator:ga5f02ffc719c4589cc7943d6fb67f34e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad101863c3a594c0a05d6bdb20dc82d0d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#gad101863c3a594c0a05d6bdb20dc82d0d">sd_ant_channel_period_get</a> (uint8_t ucChannel, uint16_t *pusPeriod)</td></tr>
<tr class="memdesc:gad101863c3a594c0a05d6bdb20dc82d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the current channel period.  <a href="#gad101863c3a594c0a05d6bdb20dc82d0d">More...</a><br/></td></tr>
<tr class="separator:gad101863c3a594c0a05d6bdb20dc82d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac19f4abd3e4d46b4b2f8f0397aa9c113"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#gac19f4abd3e4d46b4b2f8f0397aa9c113">sd_ant_channel_id_set</a> (uint8_t ucChannel, uint16_t usDeviceNumber, uint8_t ucDeviceType, uint8_t ucTransmitType)</td></tr>
<tr class="memdesc:gac19f4abd3e4d46b4b2f8f0397aa9c113"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the channel ID.  <a href="#gac19f4abd3e4d46b4b2f8f0397aa9c113">More...</a><br/></td></tr>
<tr class="separator:gac19f4abd3e4d46b4b2f8f0397aa9c113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcb9a891d63281d8e018ea923d6e6dc5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#gafcb9a891d63281d8e018ea923d6e6dc5">sd_ant_channel_id_get</a> (uint8_t ucChannel, uint16_t *pusDeviceNumber, uint8_t *pucDeviceType, uint8_t *pucTransmitType)</td></tr>
<tr class="memdesc:gafcb9a891d63281d8e018ea923d6e6dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the current Channel ID of a channel.  <a href="#gafcb9a891d63281d8e018ea923d6e6dc5">More...</a><br/></td></tr>
<tr class="separator:gafcb9a891d63281d8e018ea923d6e6dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4de80c986c5f0be170c850ea50a639a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#gaf4de80c986c5f0be170c850ea50a639a">sd_ant_search_waveform_set</a> (uint8_t ucChannel, uint16_t usWaveform)</td></tr>
<tr class="memdesc:gaf4de80c986c5f0be170c850ea50a639a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the searching waveform value of an ANT Channel.  <a href="#gaf4de80c986c5f0be170c850ea50a639a">More...</a><br/></td></tr>
<tr class="separator:gaf4de80c986c5f0be170c850ea50a639a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24478fcd9f40001d53755a15f78080fb"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#ga24478fcd9f40001d53755a15f78080fb">sd_ant_channel_rx_search_timeout_set</a> (uint8_t ucChannel, uint8_t ucTimeout)</td></tr>
<tr class="memdesc:ga24478fcd9f40001d53755a15f78080fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the receive channel search timeout.  <a href="#ga24478fcd9f40001d53755a15f78080fb">More...</a><br/></td></tr>
<tr class="separator:ga24478fcd9f40001d53755a15f78080fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3020bbb168a16049a94e39f3742a96e2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#ga3020bbb168a16049a94e39f3742a96e2">sd_ant_search_channel_priority_set</a> (uint8_t ucChannel, uint8_t ucSearchPriority)</td></tr>
<tr class="memdesc:ga3020bbb168a16049a94e39f3742a96e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the channel's search priority.  <a href="#ga3020bbb168a16049a94e39f3742a96e2">More...</a><br/></td></tr>
<tr class="separator:ga3020bbb168a16049a94e39f3742a96e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga533dff69abced3e86d35e026b1b3f2e1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#ga533dff69abced3e86d35e026b1b3f2e1">sd_ant_active_search_sharing_cycles_set</a> (uint8_t ucChannel, uint8_t ucCycles)</td></tr>
<tr class="memdesc:ga533dff69abced3e86d35e026b1b3f2e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the search cycle number of separate searching channels for active search time sharing.  <a href="#ga533dff69abced3e86d35e026b1b3f2e1">More...</a><br/></td></tr>
<tr class="separator:ga533dff69abced3e86d35e026b1b3f2e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d681d85ad32f768f4cb0139f4625d34"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#ga5d681d85ad32f768f4cb0139f4625d34">sd_ant_active_search_sharing_cycles_get</a> (uint8_t ucChannel, uint8_t *pucCycles)</td></tr>
<tr class="memdesc:ga5d681d85ad32f768f4cb0139f4625d34"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the search sharing cycles number of the specified searching channel for active search time sharing.  <a href="#ga5d681d85ad32f768f4cb0139f4625d34">More...</a><br/></td></tr>
<tr class="separator:ga5d681d85ad32f768f4cb0139f4625d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc75068807b29d6cd80266309536b605"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#gafc75068807b29d6cd80266309536b605">sd_ant_channel_low_priority_rx_search_timeout_set</a> (uint8_t ucChannel, uint8_t ucTimeout)</td></tr>
<tr class="memdesc:gafc75068807b29d6cd80266309536b605"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the low priority search timeout value of a channel.  <a href="#gafc75068807b29d6cd80266309536b605">More...</a><br/></td></tr>
<tr class="separator:gafc75068807b29d6cd80266309536b605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4919de32f0122fc9ec57e282ee7fece0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#ga4919de32f0122fc9ec57e282ee7fece0">sd_ant_adv_burst_config_set</a> (uint8_t *aucConfig, uint8_t ucSize)</td></tr>
<tr class="memdesc:ga4919de32f0122fc9ec57e282ee7fece0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the advanced burst configuration. Configuration structure is as follows:  <a href="#ga4919de32f0122fc9ec57e282ee7fece0">More...</a><br/></td></tr>
<tr class="separator:ga4919de32f0122fc9ec57e282ee7fece0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ff68f0ee4408c590755914e40a2ff64"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#ga6ff68f0ee4408c590755914e40a2ff64">sd_ant_adv_burst_config_get</a> (uint8_t ucRequestType, uint8_t *aucConfig)</td></tr>
<tr class="memdesc:ga6ff68f0ee4408c590755914e40a2ff64"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the advance burst configuration and supported capabilities.  <a href="#ga6ff68f0ee4408c590755914e40a2ff64">More...</a><br/></td></tr>
<tr class="separator:ga6ff68f0ee4408c590755914e40a2ff64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf75d7ef14fd9efe9fbad3f1892fd5c74"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#gaf75d7ef14fd9efe9fbad3f1892fd5c74">sd_ant_lib_config_set</a> (uint8_t ucANTLibConfig)</td></tr>
<tr class="memdesc:gaf75d7ef14fd9efe9fbad3f1892fd5c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the ANT Messaging Library Configuration used by Extended messaging.  <a href="#gaf75d7ef14fd9efe9fbad3f1892fd5c74">More...</a><br/></td></tr>
<tr class="separator:gaf75d7ef14fd9efe9fbad3f1892fd5c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67109fc1c0cb71cb88976d554ae3cd5d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#ga67109fc1c0cb71cb88976d554ae3cd5d">sd_ant_lib_config_clear</a> (uint8_t ucANTLibConfig)</td></tr>
<tr class="memdesc:ga67109fc1c0cb71cb88976d554ae3cd5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function clears the ANT Messaging Library Configuration.  <a href="#ga67109fc1c0cb71cb88976d554ae3cd5d">More...</a><br/></td></tr>
<tr class="separator:ga67109fc1c0cb71cb88976d554ae3cd5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5044f2aea53e57eb113fc8f4afd02b6a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#ga5044f2aea53e57eb113fc8f4afd02b6a">sd_ant_lib_config_get</a> (uint8_t *pucANTLibConfig)</td></tr>
<tr class="memdesc:ga5044f2aea53e57eb113fc8f4afd02b6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns current ANT Messaging Library Configuration.  <a href="#ga5044f2aea53e57eb113fc8f4afd02b6a">More...</a><br/></td></tr>
<tr class="separator:ga5044f2aea53e57eb113fc8f4afd02b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc8dd07669424ef4e30dfaa75fa00a82"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#gadc8dd07669424ef4e30dfaa75fa00a82">sd_ant_id_list_add</a> (uint8_t ucChannel, uint8_t *aucDevId, uint8_t ucListIndex)</td></tr>
<tr class="memdesc:gadc8dd07669424ef4e30dfaa75fa00a82"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to add a Device ID to an include or exclude list.  <a href="#gadc8dd07669424ef4e30dfaa75fa00a82">More...</a><br/></td></tr>
<tr class="separator:gadc8dd07669424ef4e30dfaa75fa00a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeaf8ece10c4b90f397fac9f760408c64"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#gaeaf8ece10c4b90f397fac9f760408c64">sd_ant_id_list_config</a> (uint8_t ucChannel, uint8_t ucIDListSize, uint8_t ucIncExcFlag)</td></tr>
<tr class="memdesc:gaeaf8ece10c4b90f397fac9f760408c64"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to configure the device ID list as include or exclude as well as the number of IDs to compare against.  <a href="#gaeaf8ece10c4b90f397fac9f760408c64">More...</a><br/></td></tr>
<tr class="separator:gaeaf8ece10c4b90f397fac9f760408c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga190f13a6952b372514157011766b68ac"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#ga190f13a6952b372514157011766b68ac">sd_ant_auto_freq_hop_table_set</a> (uint8_t ucChannel, uint8_t ucFreq0, uint8_t ucFreq1, uint8_t ucFreq2)</td></tr>
<tr class="memdesc:ga190f13a6952b372514157011766b68ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function populates the frequency hop table list. This table is used when frequency hopping is enabled on a channel via extended assignment bit.  <a href="#ga190f13a6952b372514157011766b68ac">More...</a><br/></td></tr>
<tr class="separator:ga190f13a6952b372514157011766b68ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7cbb544dccb5be899079effe993db66"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#gab7cbb544dccb5be899079effe993db66">sd_ant_event_filtering_set</a> (uint16_t usFilter)</td></tr>
<tr class="memdesc:gab7cbb544dccb5be899079effe993db66"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to specify filter configuration for channel event message generation.  <a href="#gab7cbb544dccb5be899079effe993db66">More...</a><br/></td></tr>
<tr class="separator:gab7cbb544dccb5be899079effe993db66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9297eb25b36a2cc0c6a221a3df9bd4a8"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#ga9297eb25b36a2cc0c6a221a3df9bd4a8">sd_ant_event_filtering_get</a> (uint16_t *pusFilter)</td></tr>
<tr class="memdesc:ga9297eb25b36a2cc0c6a221a3df9bd4a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to retrieve the filter configuration for channel event message generation.  <a href="#ga9297eb25b36a2cc0c6a221a3df9bd4a8">More...</a><br/></td></tr>
<tr class="separator:ga9297eb25b36a2cc0c6a221a3df9bd4a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a52294fb19c558b644c09af9834995d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#ga8a52294fb19c558b644c09af9834995d">sd_ant_active</a> (uint8_t *pbAntActive)</td></tr>
<tr class="memdesc:ga8a52294fb19c558b644c09af9834995d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the ANT activity status.  <a href="#ga8a52294fb19c558b644c09af9834995d">More...</a><br/></td></tr>
<tr class="separator:ga8a52294fb19c558b644c09af9834995d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab50ecb72e0edd83d1e8e11e50f17a210"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#gab50ecb72e0edd83d1e8e11e50f17a210">sd_ant_channel_in_progress</a> (uint8_t *pbChannelInProgress)</td></tr>
<tr class="memdesc:gab50ecb72e0edd83d1e8e11e50f17a210"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the status if the channel is in progress.  <a href="#gab50ecb72e0edd83d1e8e11e50f17a210">More...</a><br/></td></tr>
<tr class="separator:gab50ecb72e0edd83d1e8e11e50f17a210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddc5a64712fcf2117071a5136cc976f8"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#gaddc5a64712fcf2117071a5136cc976f8">sd_ant_channel_status_get</a> (uint8_t ucChannel, uint8_t *pucStatus)</td></tr>
<tr class="memdesc:gaddc5a64712fcf2117071a5136cc976f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets a specific channel's status.  <a href="#gaddc5a64712fcf2117071a5136cc976f8">More...</a><br/></td></tr>
<tr class="separator:gaddc5a64712fcf2117071a5136cc976f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c0e2144ea9c33340c3ee660eef0ebec"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#ga2c0e2144ea9c33340c3ee660eef0ebec">sd_ant_pending_transmit</a> (uint8_t ucChannel, uint8_t *pucPending)</td></tr>
<tr class="memdesc:ga2c0e2144ea9c33340c3ee660eef0ebec"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function determines if there is a pending transmission on a specific channel.  <a href="#ga2c0e2144ea9c33340c3ee660eef0ebec">More...</a><br/></td></tr>
<tr class="separator:ga2c0e2144ea9c33340c3ee660eef0ebec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bb311b7dfbb4457119e5144de9008a7"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#ga0bb311b7dfbb4457119e5144de9008a7">sd_ant_cw_test_mode_init</a> (void)</td></tr>
<tr class="memdesc:ga0bb311b7dfbb4457119e5144de9008a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initialize the stack to get ready for a continuous wave transmission test.  <a href="#ga0bb311b7dfbb4457119e5144de9008a7">More...</a><br/></td></tr>
<tr class="separator:ga0bb311b7dfbb4457119e5144de9008a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1df5c028bfac304e6db70ed61da29c56"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#ga1df5c028bfac304e6db70ed61da29c56">sd_ant_cw_test_mode</a> (uint8_t ucRadioFreq, uint8_t ucTxPower, uint8_t ucCustomTxPower)</td></tr>
<tr class="memdesc:ga1df5c028bfac304e6db70ed61da29c56"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function starts a continuous wave test mode transmission.  <a href="#ga1df5c028bfac304e6db70ed61da29c56">More...</a><br/></td></tr>
<tr class="separator:ga1df5c028bfac304e6db70ed61da29c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga529f053ac81ed70c97ade5a8ee7ddb4f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#ga529f053ac81ed70c97ade5a8ee7ddb4f">sd_ant_version_get</a> (uint8_t *aucVersion)</td></tr>
<tr class="memdesc:ga529f053ac81ed70c97ade5a8ee7ddb4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the version string of the ANT stack.  <a href="#ga529f053ac81ed70c97ade5a8ee7ddb4f">More...</a><br/></td></tr>
<tr class="separator:ga529f053ac81ed70c97ade5a8ee7ddb4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ae3c048f41006e2beb531a5e875385d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#ga6ae3c048f41006e2beb531a5e875385d">sd_ant_capabilities_get</a> (uint8_t *aucCapabilities)</td></tr>
<tr class="memdesc:ga6ae3c048f41006e2beb531a5e875385d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the capabilities of the stack.  <a href="#ga6ae3c048f41006e2beb531a5e875385d">More...</a><br/></td></tr>
<tr class="separator:ga6ae3c048f41006e2beb531a5e875385d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9555406ba64e0005d0ae57e346910026"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#ga9555406ba64e0005d0ae57e346910026">sd_ant_burst_handler_wait_flag_enable</a> (uint8_t *pucWaitFlag)</td></tr>
<tr class="memdesc:ga9555406ba64e0005d0ae57e346910026"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function assigns a wait variable to the the burst handler. When the input buffer is locked by the handler the wait flag is set to 1. When the.  <a href="#ga9555406ba64e0005d0ae57e346910026">More...</a><br/></td></tr>
<tr class="separator:ga9555406ba64e0005d0ae57e346910026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4cc4eb62a0b01c7bdc2b235e4417184"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#gab4cc4eb62a0b01c7bdc2b235e4417184">sd_ant_burst_handler_wait_flag_disable</a> (void)</td></tr>
<tr class="memdesc:gab4cc4eb62a0b01c7bdc2b235e4417184"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function unassigns any previously assigned wait variable from the burst handler. The burst handler returns to the default method in generating.  <a href="#gab4cc4eb62a0b01c7bdc2b235e4417184">More...</a><br/></td></tr>
<tr class="separator:gab4cc4eb62a0b01c7bdc2b235e4417184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga231d8b588e95f769b07b6fbdd879d439"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#ga231d8b588e95f769b07b6fbdd879d439">sd_ant_sdu_mask_set</a> (uint8_t ucMask, uint8_t *aucMask)</td></tr>
<tr class="memdesc:ga231d8b588e95f769b07b6fbdd879d439"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to assign a selective data update (SDU) mask (8 octets) to an identifier, ucMask.  <a href="#ga231d8b588e95f769b07b6fbdd879d439">More...</a><br/></td></tr>
<tr class="separator:ga231d8b588e95f769b07b6fbdd879d439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b975a9f6539705f63863d11d8ca4f23"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#ga9b975a9f6539705f63863d11d8ca4f23">sd_ant_sdu_mask_get</a> (uint8_t ucMask, uint8_t *aucMask)</td></tr>
<tr class="memdesc:ga9b975a9f6539705f63863d11d8ca4f23"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the selective data update (SDU) mask (8 octets) from the specified identifier, ucMask.  <a href="#ga9b975a9f6539705f63863d11d8ca4f23">More...</a><br/></td></tr>
<tr class="separator:ga9b975a9f6539705f63863d11d8ca4f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23878b31b61d3314ed4a315a55afca90"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#ga23878b31b61d3314ed4a315a55afca90">sd_ant_sdu_mask_config</a> (uint8_t ucChannel, uint8_t ucMaskConfig)</td></tr>
<tr class="memdesc:ga23878b31b61d3314ed4a315a55afca90"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function assigns a SDU mask configuration to a particular channel. The configuration specifies the mask identifier and the type of rx data in which the mask should be applied to.  <a href="#ga23878b31b61d3314ed4a315a55afca90">More...</a><br/></td></tr>
<tr class="separator:ga23878b31b61d3314ed4a315a55afca90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d633f9ec84b9a81063dbb29ad675ed1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#ga1d633f9ec84b9a81063dbb29ad675ed1">sd_ant_crypto_channel_enable</a> (uint8_t ucChannel, uint8_t ucEnable, uint8_t ucKeyNum, uint8_t ucDecimationRate)</td></tr>
<tr class="memdesc:ga1d633f9ec84b9a81063dbb29ad675ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables/disables 128-bit AES encryption mode to the specified channel. Advanced burst must be enabled beforehand to enable encrypted channel.  <a href="#ga1d633f9ec84b9a81063dbb29ad675ed1">More...</a><br/></td></tr>
<tr class="separator:ga1d633f9ec84b9a81063dbb29ad675ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabaf590fd95860473bdd4a99f91443453"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#gabaf590fd95860473bdd4a99f91443453">sd_ant_crypto_key_set</a> (uint8_t ucKeyNum, uint8_t *aucKey)</td></tr>
<tr class="memdesc:gabaf590fd95860473bdd4a99f91443453"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function assigns a 128-bit AES encryption key to a key index.  <a href="#gabaf590fd95860473bdd4a99f91443453">More...</a><br/></td></tr>
<tr class="separator:gabaf590fd95860473bdd4a99f91443453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04b1c52c190dd267646f9968488c6c3f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#ga04b1c52c190dd267646f9968488c6c3f">sd_ant_crypto_info_set</a> (uint8_t ucType, uint8_t *aucInfo)</td></tr>
<tr class="memdesc:ga04b1c52c190dd267646f9968488c6c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets specific information to be exchanged between the channel master and slave during encryption channel set-up/negotiation.  <a href="#ga04b1c52c190dd267646f9968488c6c3f">More...</a><br/></td></tr>
<tr class="separator:ga04b1c52c190dd267646f9968488c6c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84f62c111be73ea126866e9d097a1480"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#ga84f62c111be73ea126866e9d097a1480">sd_ant_crypto_info_get</a> (uint8_t ucType, uint8_t *aucInfo)</td></tr>
<tr class="memdesc:ga84f62c111be73ea126866e9d097a1480"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function retrieves specific information to be exchanged between the channel master and slave during encryption channel set-up/negotiation.  <a href="#ga84f62c111be73ea126866e9d097a1480">More...</a><br/></td></tr>
<tr class="separator:ga84f62c111be73ea126866e9d097a1480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74d5df5b5e66bf6d40b283e80842c0c5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#ga74d5df5b5e66bf6d40b283e80842c0c5">sd_ant_rfactive_notification_config_set</a> (uint8_t ucMode, uint16_t usTimeThreshold)</td></tr>
<tr class="memdesc:ga74d5df5b5e66bf6d40b283e80842c0c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables/disables event notifications to be generated to the application indicating the time to the next ANT radio activity exceeds the configured time threshold.  <a href="#ga74d5df5b5e66bf6d40b283e80842c0c5">More...</a><br/></td></tr>
<tr class="separator:ga74d5df5b5e66bf6d40b283e80842c0c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa66114d4387791c8b4b20317698d6cb1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#gaa66114d4387791c8b4b20317698d6cb1">sd_ant_rfactive_notification_config_get</a> (uint8_t *pucMode, uint16_t *pusTimeThreshold)</td></tr>
<tr class="memdesc:gaa66114d4387791c8b4b20317698d6cb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function retrieves the ANT rf active notification configuration.  <a href="#gaa66114d4387791c8b4b20317698d6cb1">More...</a><br/></td></tr>
<tr class="separator:gaa66114d4387791c8b4b20317698d6cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d3160bb4b871386f7bb034560d7e2f8"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#ga3d3160bb4b871386f7bb034560d7e2f8">sd_ant_coex_config_set</a> (uint8_t ucChannel, uint8_t *aucCoexConfig, uint8_t *aucAdvCoexConfig)</td></tr>
<tr class="memdesc:ga3d3160bb4b871386f7bb034560d7e2f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets ANT radio coexistence behaviour. Supported only if ANT is sharing radio HW concurrently with another wireless protocol.  <a href="#ga3d3160bb4b871386f7bb034560d7e2f8">More...</a><br/></td></tr>
<tr class="separator:ga3d3160bb4b871386f7bb034560d7e2f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16e892debd12d16a358f91588c83698b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#ga16e892debd12d16a358f91588c83698b">sd_ant_coex_config_get</a> (uint8_t ucChannel, uint8_t *aucCoexConfig, uint8_t *aucAdvCoexConfig)</td></tr>
<tr class="memdesc:ga16e892debd12d16a358f91588c83698b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function retrieves the configured ANT radio coexistence behaviour as described in ant_coex_config_set.  <a href="#ga16e892debd12d16a358f91588c83698b">More...</a><br/></td></tr>
<tr class="separator:ga16e892debd12d16a358f91588c83698b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga189c32f9961170ecbb902b0a782b370d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#ga189c32f9961170ecbb902b0a782b370d">sd_ant_extended0</a> (uint8_t ucExtID, void *pvArg0, void *pvArg1, void *pvArg2)</td></tr>
<tr class="memdesc:ga189c32f9961170ecbb902b0a782b370d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extended0 ANT SVCs. Access extended SVC functions via ucExtID.  <a href="#ga189c32f9961170ecbb902b0a782b370d">More...</a><br/></td></tr>
<tr class="separator:ga189c32f9961170ecbb902b0a782b370d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga173df306406ac80072cb45b48023152a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#ga173df306406ac80072cb45b48023152a">SD_ANT_EXT0_ID_WAKEON_RF_ACTIVITY_CONFIG_SET</a>&#160;&#160;&#160;0x00</td></tr>
<tr class="memdesc:ga173df306406ac80072cb45b48023152a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configures CPU wake on ANT RF activity behaviour. CPU is woken up via generation of SD_EVENT_IRQn interrupt upon the start of specified RF activity. In.  <a href="#ga173df306406ac80072cb45b48023152a">More...</a><br/></td></tr>
<tr class="separator:ga173df306406ac80072cb45b48023152a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79ddab60f878ad07e39785a2a11f469e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#ga79ddab60f878ad07e39785a2a11f469e">SD_ANT_EXT0_ID_WAKEON_RF_ACTIVITY_CONFIG_GET</a>&#160;&#160;&#160;0x01</td></tr>
<tr class="memdesc:ga79ddab60f878ad07e39785a2a11f469e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function retrieves the configured CPU wake on ANT RF activity behaviour.  <a href="#ga79ddab60f878ad07e39785a2a11f469e">More...</a><br/></td></tr>
<tr class="separator:ga79ddab60f878ad07e39785a2a11f469e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada055d3c56e60eadb66f49f2e00b04d6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00383.html#gada055d3c56e60eadb66f49f2e00b04d6">SD_ANT_EXT0_ID_ENHANCED_CHANNEL_SPACING_SET</a>&#160;&#160;&#160;0x02</td></tr>
<tr class="memdesc:gada055d3c56e60eadb66f49f2e00b04d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables or disables a feature for preventing long periods of consecutive multi-tracking channel collisions. This feature is.  <a href="#gada055d3c56e60eadb66f49f2e00b04d6">More...</a><br/></td></tr>
<tr class="separator:gada055d3c56e60eadb66f49f2e00b04d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>ANT Stack Application Programming Interface (API). </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gada055d3c56e60eadb66f49f2e00b04d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SD_ANT_EXT0_ID_ENHANCED_CHANNEL_SPACING_SET&#160;&#160;&#160;0x02</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables or disables a feature for preventing long periods of consecutive multi-tracking channel collisions. This feature is. </p>
<pre class="fragment">     enabled by default/upon stack reset.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucExtID</td><td>= SD_ANT_EXT0_ID_ENHANCED_CHANNEL_SPACING_SET</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pvArg0</td><td>is a pointer to unsigned char (1 octet) denoting enable/disable control. See Enhanced Channel Spacing Defines in ant_parameters.h</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pvArg1</td><td>is unused. Set to NULL.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pvArg2</td><td>is unused. Set to NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ERROR_INVALID_PARAM</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="ga79ddab60f878ad07e39785a2a11f469e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SD_ANT_EXT0_ID_WAKEON_RF_ACTIVITY_CONFIG_GET&#160;&#160;&#160;0x01</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function retrieves the configured CPU wake on ANT RF activity behaviour. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucExtID</td><td>= SD_ANT_EXT0_ID_WAKEON_RF_ACTIVITY_CONFIG_GET</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pvArg0</td><td>is a pointer to unsigned char (1 octet) denoting where the CPU wakeup configuration will be stored.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pvArg1</td><td>is unused. Set to NULL.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pvArg2</td><td>is unused. Set to NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ERROR_INVALID_PARAM</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="ga173df306406ac80072cb45b48023152a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SD_ANT_EXT0_ID_WAKEON_RF_ACTIVITY_CONFIG_SET&#160;&#160;&#160;0x00</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function configures CPU wake on ANT RF activity behaviour. CPU is woken up via generation of SD_EVENT_IRQn interrupt upon the start of specified RF activity. In. </p>
<pre class="fragment">     order to wakeup in the event that SD_EVENT_IRQn is disabled, the SEVONPEND flag has to be set in the Cortex-M0 System Control Register (SCR). CPU is dissallowed from

     entering low power state when calling sd_app_event_wait() for the duration of the RF activity. The intention of this function is to allow/disallow sudden shifts in

     current consumption during RF transmission/ RF reception window which may impact RF performance. When enabled there is a slight increase in average current consumption for

     ANT activities.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucExtID</td><td>= SD_ANT_EXT0_ID_WAKEON_RF_ACTIVITY_CONFIG_SET</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pvArg0</td><td>is a pointer to unsigned char (1 octet) denoting the CPU wakeup configuration. See Wake On RF Activity Defines in ant_parameters.h.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pvArg1</td><td>is unused. Set to NULL.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pvArg2</td><td>is unused. Set to NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ERROR_INVALID_PARAM</pre> </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga893d871362f4eaf1e82a6749af27136b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_acknowledge_message_tx </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>aucMesg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to send an acknowledge message. This message requests an acknowledgement from the slave to validate reception. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel to send the data on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucSize</td><td>is an unsigned char (1 octet) denoting the size of the message, ucSize must be 8.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aucMesg</td><td>is the buffer where the message is located (array must be 8 octets).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ERROR_INVALID_PARAM

     ::NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED

     ::NRF_ANT_ERROR_MESSAGE_SIZE_EXCEEDS_LIMIT

     ::NRF_ANT_ERROR_INVALID_SCAN_TX_CHANNEL

     ::NRF_ANT_ERROR_CHANNEL_IN_WRONG_STATE

     ::NRF_ANT_ERROR_TRANSFER_IN_PROGRESS

     ::NRF_ANT_ERROR_TRANSFER_IN_ERROR</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="ga8a52294fb19c558b644c09af9834995d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_active </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pbAntActive</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the ANT activity status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pbAntActive</td><td>is the pointer to an unsigned char (1 octet) where the ANT activity value will be stored. 1 = active, 0 = otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ERROR_INVALID_PARAM</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="ga5d681d85ad32f768f4cb0139f4625d34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_active_search_sharing_cycles_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pucCycles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the search sharing cycles number of the specified searching channel for active search time sharing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel number to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pucCycles</td><td>is the pointer to an unsigned char (1 octet) where the cycle value will be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ERROR_INVALID_PARAM

     ::NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="ga533dff69abced3e86d35e026b1b3f2e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_active_search_sharing_cycles_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucCycles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the search cycle number of separate searching channels for active search time sharing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel number to configure.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucCycles</td><td>is an unsigned char (1 octet) denoting the number of cycles to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="ga6ff68f0ee4408c590755914e40a2ff64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_adv_burst_config_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucRequestType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>aucConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the advance burst configuration and supported capabilities. </p>
<pre class="fragment">    Returned structure is as follows for configuration:

    Byte0 = RF payload size. See Advanced Burst Configuration Defines in ant_parameters.h.

    Byte1 = Required advanced burst modes. See Advanced Burst Configuration Defines in ant_parameters.h.

    Byte2 = 0, Reserved

    Byte3 = 0, Reserved

    Byte4 = Optional advanced burst modes. See Advanced Burst Configuration Defines in ant_parameters.h.

    Byte5 = 0, Reserved

    Byte6 = 0, Reserved

    Byte7 = Advanced burst stalling count config LSB. Each count represents ~3ms of stalling.

    Byte8 = Advanced burst stalling count config MSB

    Byte9 = Advanced burst retry count cycle extension. Each count cycle represents 5 retries.

    Returned structure is as follows for capabilities:

    Byte0 = Supported RF payload size. See Advanced Burst Configuration Defines in ant_parameters.h.

    Byte1 = Supported burst configurations. See Advanced Burst Configuration Defines in ant_parameters.h.

    Byte2 = 0, Reserved

    Byte3 = 0, Reserved
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucRequestType</td><td>is an unsigned char (1 octet) denoting the type of request. 1 = configuration, 0 = capability.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">aucConfig</td><td>is the pointer to the buffer where the configuration/capabilities will be read to. The array should be at least 10 octets</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ERROR_INVALID_PARAM</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="ga4919de32f0122fc9ec57e282ee7fece0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_adv_burst_config_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>aucConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the advanced burst configuration. Configuration structure is as follows: </p>
<pre class="fragment">    Required Byte0 = 0-Disable, 1-Enable. See Advanced Burst Configuration Defines in ant_parameters.h.

    Required Byte1 = RF payload size. See Advanced Burst Configuration Defines in ant_parameters.h.

    Required Byte2 = Required advanced burst modes. See Advanced Burst Configuration Defines in ant_parameters.h.

    Required Byte3 = 0, Reserved

    Required Byte4 = 0, Reserved

    Required Byte5 = Optional advanced burst modes. See Advanced Burst Configuration Defines in ant_parameters.h.

    Required Byte6 = 0, Reserved

    Required Byte7 = 0, Reserved

    Optional Byte8 = Advanced burst stalling count config LSB. Typical is 3210 (~10s of stalling) where each count represents ~3ms of stalling.

    Optional Byte9 = Advanced burst stalling count config MSB.

    Optional Byte10 = Advanced burst retry count cycle extension. Typical is 3 (15 retries) where each count cycles represents 5 retries.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aucConfig</td><td>is a buffer containing the advanced burst configuration to be set (as stated above).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucSize</td><td>is an unsigned char (1 octet) denoting the size of the configuration parameter buffer. Minimum config set is 8 octets, maximum is 11 octets.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ERROR_INVALID_PARAM

     ::NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="ga190f13a6952b372514157011766b68ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_auto_freq_hop_table_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucFreq0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucFreq1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucFreq2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function populates the frequency hop table list. This table is used when frequency hopping is enabled on a channel via extended assignment bit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel number to set the frequency hop table list.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucFreq0</td><td>is an unsigned char (1 octet) denoting the offset from 2400MHz of the 1st frequency hop value.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucFreq1</td><td>is an unsigned char (1 octet) denoting the offset from 2400MHz of the 2nd frequency hop value.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucFreq2</td><td>is an unsigned char (1 octet) denoting the offset from 2400MHz of the 3rd frequency hop value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="ga2e48883c0e50c1c380b61fd0c28b3879"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_broadcast_message_tx </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>aucMesg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to set broadcast data for transmission. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel to send the data on.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucSize</td><td>is an unsigned char (1 octet) denoting the size of the message, ucSize must be 8.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aucMesg</td><td>is the buffer where the message is located (array must be 8 octets).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ERROR_INVALID_PARAM

     ::NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED

     ::NRF_ANT_ERROR_MESSAGE_SIZE_EXCEEDS_LIMIT

     ::NRF_ANT_ERROR_INVALID_SCAN_TX_CHANNEL

     ::NRF_ANT_ERROR_CHANNEL_IN_WRONG_STATE

     ::NRF_ANT_ERROR_TRANSFER_IN_PROGRESS

     ::NRF_ANT_ERROR_TRANSFER_IN_ERROR</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="gaa09761cfc5e7373048e90e2dca208e6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_burst_handler_request </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>usSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>aucData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucBurstSegment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to queue data for burst transmission. After every successful call, the input buffer is held in use by the burst handler and must not be changed. </p>
<pre class="fragment">    When the burst handler releases the input buffer, it will either generate a EVENT_TRANSFER_NEXT_DATA_BLOCK event or clear a specified wait flag assigned to the

    burst handler. Transfer end events: EVENT_TRANSFER_TX_COMPLETED and EVENT_TRANSFER_TX_FAILED also releases the input buffer. Special care must be made to ensure that

    the input buffer does not change until it is released by the burst handler to avoid data corruption. Use of burst segment identifiers (BURST_SEGMENT_START, BURST_SEGMENT_CONTINUE,

    and BURST_SEGMENT_END) is required to indicate the sequence of the data block being sent as a burst transfer.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel to do a burst transmission.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">usSize</td><td>is an unsigned short (2 octets) denoting the size of the message block. Size must be divisible by 8.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aucData</td><td>is the buffer where the message block is located.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucBurstSegment</td><td>is an unsigned char (1 octet) containing a bitfield representing the message block type. See Tx Burst Handler Request Segment Defines in ant_parameters.h.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ERROR_INVALID_PARAM

     ::NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED

     ::NRF_ANT_ERROR_INVALID_SCAN_TX_CHANNEL

     ::NRF_ANT_ERROR_CHANNEL_NOT_OPENED

     ::NRF_ANT_ERROR_TRANSFER_SEQUENCE_NUMBER_ERROR

     ::NRF_ANT_ERROR_TRANSFER_IN_PROGRESS

     ::NRF_ANT_ERROR_TRANSFER_IN_ERROR

     ::NRF_ANT_ERROR_MESSAGE_SIZE_EXCEEDS_LIMIT

     ::NRF_ANT_ERROR_CHANNEL_IN_WRONG_STATE

     ::NRF_ANT_ERROR_TRANSFER_BUSY</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="gab4cc4eb62a0b01c7bdc2b235e4417184"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_burst_handler_wait_flag_disable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function unassigns any previously assigned wait variable from the burst handler. The burst handler returns to the default method in generating. </p>
<pre class="fragment">    EVENT_TRANSFER_NEXT_DATA_BLOCK to indicate input buffer unlock.
</pre><dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ERROR_INVALID_PARAM

     ::NRF_ANT_ERROR_TRANSFER_IN_PROGRESS</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="ga9555406ba64e0005d0ae57e346910026"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_burst_handler_wait_flag_enable </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pucWaitFlag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function assigns a wait variable to the the burst handler. When the input buffer is locked by the handler the wait flag is set to 1. When the. </p>
<pre class="fragment">    input buffer is unlocked, the wait flag is set to 0. When a wait flag is assigned, EVENT_TRANSFER_NEXT_DATA_BLOCK events will not

    be generated until the wait flag unassigned. The wait flag should be declared as a static variable.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pucWaitFlag</td><td>is the pointer to a static unsigned char (1 octet) where the status of the burst handler will be updated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ERROR_INVALID_PARAM

     ::NRF_ANT_ERROR_TRANSFER_IN_PROGRESS</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="ga6ae3c048f41006e2beb531a5e875385d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_capabilities_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>aucCapabilities</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the capabilities of the stack. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">aucCapabilities</td><td>is the pointer to the buffer where the capabilities message will be copied, the array should be at least 8 octets. <pre class="fragment">        Byte0 = Maximum supported ANT channels

        Byte1 = Maximum supported ANT networks

        Byte2 = CAPABILITIES_STANDARD. See Standard capabilities defines in ant_parameters.h

        Byte3 = CAPABILITIES_ADVANCED. See Advanced capabilities defines in ant_parameters.h

        Byte4 = CAPABILITIES_ADVANCED_2. See Advanced capabilities 2 defines in ant_parameters.h

        Byte5 = Maximum support ANT data channels (only applicable for SensRcore support)

        Byte6 = CAPABILITIES_ADVANCED_3. See Advanced capabilities 3 defines in ant_parameters.h

        Byte7 = CAPABILITIES_ADVANCED_4. Advanced capabilities 4 defines in ant_parameters.h
</pre></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ERROR_INVALID_PARAM</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="ga0ee008ec03098a855dd200c9cec28854"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_channel_assign </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannelType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucNetwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucExtAssign</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function assigns and initializes a new channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel to assign.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannelType</td><td>is an unsigned char (1 octet) denoting the channel type. See Assign Channel Parameters/Assign Channel Types in ant_parameters.h.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucNetwork</td><td>is an unsigned char (1 octet) denoting the network key to associate with the channel.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucExtAssign</td><td>is a bit field (1 octet) for an extended assign. See Ext. Assign Channel Parameters in ant_parameters.h.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED

     ::NRF_ANT_ERROR_INVALID_NETWORK_NUMBER

     ::NRF_ANT_ERROR_CHANNEL_IN_WRONG_STATE</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="gad6b069b1d3147d0bcac9505efa60dea6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_channel_close </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function closes a channel. The channel must be in an open state (SEARCHING or TRACKING). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel to close.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED

     ::NRF_ANT_ERROR_CHANNEL_IN_WRONG_STATE</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="gafcb9a891d63281d8e018ea923d6e6dc5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_channel_id_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>pusDeviceNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pucDeviceType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pucTransmitType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the current Channel ID of a channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel number to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pusDeviceNumber</td><td>is the pointer to an unsigned short (2 octets) where the device number will be stored.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pucDeviceType</td><td>is the pointer to an unsigned char (1 octet) where the device type will be stored.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pucTransmitType</td><td>is the pointer to an unsigned char (1 octet) where the transmit type will be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ERROR_INVALID_PARAM

     ::NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="gac19f4abd3e4d46b4b2f8f0397aa9c113"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_channel_id_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>usDeviceNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucDeviceType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucTransmitType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the channel ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel number to set.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">usDeviceNumber</td><td>is an unsigned short (2 octets) denoting the device number.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucDeviceType</td><td>is an unsigned char (1 octet) denoting the device type.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucTransmitType</td><td>is an unsigned char (1 octet) denoting the transmission type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="gab50ecb72e0edd83d1e8e11e50f17a210"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_channel_in_progress </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pbChannelInProgress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the status if the channel is in progress. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pbChannelInProgress</td><td>is the pointer to an unsigned char (1 octet) where the result will be stored. 1 = in progress, 0 = otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ERROR_INVALID_PARAM</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="gafc75068807b29d6cd80266309536b605"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_channel_low_priority_rx_search_timeout_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucTimeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the low priority search timeout value of a channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel number to set.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucTimeout</td><td>is an unsigned char (1 octet) denoting the timeout value in 2.5 seconds increments. Default = 2 (5s).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="gae47817e299d072bc4c9b1c75123a20e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_channel_open </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function opens and activates a channel. The channel to open must be in an assigned state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel to open.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED

     ::NRF_ANT_ERROR_CHANNEL_IN_WRONG_STATE</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="gad101863c3a594c0a05d6bdb20dc82d0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_channel_period_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>pusPeriod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the current channel period. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel number to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pusPeriod</td><td>is the pointer to an unsigned short (2 octets) where the channel period will be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ERROR_INVALID_PARAM

     ::NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="ga5f02ffc719c4589cc7943d6fb67f34e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_channel_period_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>usPeriod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the channel period. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel number to set the period to.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">usPeriod</td><td>is an unsigned short (2 octets) denoting the period in 32 kHz counts (usPeriod/32768 s).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="ga874e9c551db1f3297a0253c5142106bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_channel_radio_freq_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pucRfreq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the radio frequency of an ANT channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel number to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pucRfreq</td><td>is the pointer to an unsigned char (1 octet) where the frequency will be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ERROR_INVALID_PARAM

     ::NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="ga28b87b0df8a35fe5e8ffb23e7bd89967"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_channel_radio_freq_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucFreq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the radio frequency of an ANT channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel number to set to.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucFreq</td><td>is an unsigned char (1 octet) denoting the radio frequency offset from 2400MHz (eg. 2466MHz, ucFreq = 66).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ANT_ERROR_INVALID_NETWORK_NUMBER</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="ga70e472a2603eb90c0a6a8af71e764135"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_channel_radio_tx_power_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucTxPower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucCustomTxPower</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the radio tx power. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel number to assign the radio tx power.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucTxPower</td><td>is an unsigned char (1 octet) denoting the ANT transmit power index. See Radio TX Power Definitions in ant_parameters.h.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucCustomTxPower</td><td>is an unsigned char (1 octet) denoting the custom nRF transmit power as defined in nrf51_bitfields.h. Only applicable if ucTxPower is set to custom tx power selection.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="ga24478fcd9f40001d53755a15f78080fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_channel_rx_search_timeout_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucTimeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the receive channel search timeout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel number to set.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucTimeout</td><td>is an unsigned char (1 octet) denoting the timeout value in 2.5 second increments. Default = 10 (25s).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="gaddc5a64712fcf2117071a5136cc976f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_channel_status_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pucStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets a specific channel's status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel number to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pucStatus</td><td>is the pointer to an unsigned char (1 octet) where the channel status will be stored. See Channel Status in ant_parameters.h.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ERROR_INVALID_PARAM

     ::NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="gafe35f6cb447e86746361f1411953c171"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_channel_unassign </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function unassigns a channel. The channel to unassign must be in an assigned state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel to unassign.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED

     ::NRF_ANT_ERROR_CHANNEL_IN_WRONG_STATE</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="ga16e892debd12d16a358f91588c83698b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_coex_config_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>aucCoexConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>aucAdvCoexConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function retrieves the configured ANT radio coexistence behaviour as described in ant_coex_config_set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">aucCoexConfig</td><td>is the pointer to a buffer where the coexistence configuration will be stored. Must be at least 8 octet in size. Set as null to ignore.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">aucAdvCoexConfig</td><td>is the pointer to a buffer where the advanced coexistence configuration will be stored. Must be at least 8 octet in size. Set as null to ignore.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ERROR_INVALID_PARAM</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="ga3d3160bb4b871386f7bb034560d7e2f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_coex_config_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>aucCoexConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>aucAdvCoexConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets ANT radio coexistence behaviour. Supported only if ANT is sharing radio HW concurrently with another wireless protocol. </p>
<pre class="fragment">     Configuration structure is as follows:

     Byte0 = Configuration enable bitfield

             bit0 - enable/disable tx/rx channel keep alive config (Byte4/5 &amp; Byte6/7)

             bit1 - enable/disable tx/rx channel fixed interval priority config (Byte1)

             bit2 - enable/disable transfer keep alive config (Byte2)

             bit3 - enable/disable search channel fixed interval priority config (Byte3)

             else - reserved

     Byte1 = tx/rx channel fixed interval priority configuration

     Byte2 = transfer keep alive configuration

     Byte3 = search channel fixed interval priority configuration

     Byte4(LSB)/Byte5(MSB) = tx channel keep alive configuration

     Byte6(LSB)/Byte7(MSB) = rx channel keep alive configuration

     Advanced configuration structure is as follows:

     Byte0 = Configuration enable bitfield

             bit0 - enable/disable priority override config (Byte1)

             bit1-7 - reserved

     Byte1 = ANT priority override. 0 = low, 1 = normal(default), 2 = high, 3 = critical

     Byte2 = Reserved

     Byte3 = Reserved

     Byte4 = Reserved

     Byte5 = Reserved

     Byte6 = Reserved

     Byte7 = Reserved
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel for which the coexistence configuration is to be set.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aucCoexConfig</td><td>is a buffer containing the coex configuration to be set. Must be 8 octet in size. Set as null for no change.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aucAdvCoexConfig</td><td>is a buffer containing the advanced coex configuration to be set. Must be 8 octet in size. Set as null for no change.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ERROR_INVALID_PARAM</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="ga1d633f9ec84b9a81063dbb29ad675ed1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_crypto_channel_enable </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucEnable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucKeyNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucDecimationRate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables/disables 128-bit AES encryption mode to the specified channel. Advanced burst must be enabled beforehand to enable encrypted channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel in which encryption mode is set.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucEnable</td><td>is an unsigned char (1 octet) denoting the encryption mode. See Encrypted Channel Defines in ant_parameters.h.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucKeyNum</td><td>is an unsigned char (1 octet) denoting the key index of the 128-bit key to be used for encryption. Currently, only key index 0 can be used.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucDecimationRate</td><td>is an unsigned char (1 octet) denoting the decimate rate to apply for encrypted slave channel. Must be &gt; 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED

     ::NRF_ANT_ERROR_INVALID_SCAN_TX_CHANNEL

     ::NRF_ANT_ERROR_CHANNEL_NOT_OPENED

     ::NRF_ANT_ERROR_TRANSFER_SEQUENCE_NUMBER_ERROR

     ::NRF_ANT_ERROR_TRANSFER_IN_PROGRESS

     ::NRF_ANT_ERROR_TRANSFER_IN_ERROR

     ::NRF_ANT_ERROR_MESSAGE_SIZE_EXCEEDS_LIMIT

     ::NRF_ANT_ERROR_CHANNEL_IN_WRONG_STATE

     ::NRF_ANT_ERROR_TRANSFER_BUSY</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="ga84f62c111be73ea126866e9d097a1480"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_crypto_info_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>aucInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function retrieves specific information to be exchanged between the channel master and slave during encryption channel set-up/negotiation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucType</td><td>is an unsigned char (1 octet) denoting the type of information being requested. See Encrypted Channel Defines in ant_parameters.h.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">aucInfo</td><td>is a pointer to a buffer in which the information retrieved will be copied to (1 octet for supported mode, 4 octets for ID, 19 octets for custom user data).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ERROR_INVALID_PARAM</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="ga04b1c52c190dd267646f9968488c6c3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_crypto_info_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>aucInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets specific information to be exchanged between the channel master and slave during encryption channel set-up/negotiation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucType</td><td>is an unsigned char (1 octet) denoting the type of information being set. See Encrypted Channel Defines in ant_parameters.h.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aucInfo</td><td>is a buffer containing the information being set (4 octets for ID, 19 octets for custom user data).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ERROR_INVALID_PARAM

     ::NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="gabaf590fd95860473bdd4a99f91443453"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_crypto_key_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucKeyNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>aucKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function assigns a 128-bit AES encryption key to a key index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucKeyNum</td><td>is an unsigned char (1 octet) denoting the key index for assignment. Currently, only key index 0 can be used.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aucKey</td><td>is a buffer (16 octets) containing the 128-bit AES key to be assigned to the key index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ERROR_INVALID_PARAM

     ::NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="ga1df5c028bfac304e6db70ed61da29c56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_cw_test_mode </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucRadioFreq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucTxPower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucCustomTxPower</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function starts a continuous wave test mode transmission. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucRadioFreq</td><td>is an unsigned char (1 octet) denoting the radio frequency offset from 2400MHz for continuous wave mode. (eg. 2466MHz, ucRadioFreq = 66).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucTxPower</td><td>is an unsigned char (1 octet) denoting the ANT transmit power index for continuous wave mode. See Radio TX Power Definitions in ant_parameters.h</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucCustomTxPower</td><td>is an unsigned char (1 octet) denoting the custom nRF transmit power as defined in nrf51_bitfields.h. Only applicable if ucTxPower is set to custom tx power selection.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga0bb311b7dfbb4457119e5144de9008a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_cw_test_mode_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initialize the stack to get ready for a continuous wave transmission test. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga9297eb25b36a2cc0c6a221a3df9bd4a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_event_filtering_get </td>
          <td>(</td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>pusFilter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to retrieve the filter configuration for channel event message generation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pusFilter</td><td>is the pointer to an unsigned short (2 octets) where the filter configuration will be stored. See Event Filtering in ant_parameters.h.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ERROR_INVALID_PARAM</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="gab7cbb544dccb5be899079effe993db66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_event_filtering_set </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>usFilter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to specify filter configuration for channel event message generation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">usFilter</td><td>is an unsigned short (2 octets) denoting the filter configuration bitfield. See Event Filtering in ant_parameters.h.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga871ce84112f0aa7dc40468a7d6b3fdbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_event_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pucEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>aucANTMesg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns ANT channel events and data messages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pucChannel</td><td>is the pointer to an unsigned char (1 octet) where the channel number will be copied.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pucEvent</td><td>is the pointer to an unsigned char (1 octet) where the event code will be copied. See Channel Events and Command Response Codes in ant_parameters.h.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">aucANTMesg</td><td>is the buffer where event's message will be copied. The array size must be at least MESG_BUFFER_SIZE to accommadate the entire ANT_MESSAGE structure size. See ANT Message Structure in ant_parameters.h.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></dd>
<dd>
<a class="el" href="a00385.html#ga0a5831cf5092e0dd43a01869676ee076" title="Invalid Parameter.">NRF_ERROR_INVALID_PARAM</a></dd>
<dd>
<a class="el" href="a00385.html#ga349d25ada15be023e0d507f45ada682c" title="Not found.">NRF_ERROR_NOT_FOUND</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga189c32f9961170ecbb902b0a782b370d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_extended0 </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucExtID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvArg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvArg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvArg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extended0 ANT SVCs. Access extended SVC functions via ucExtID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucExtID</td><td>is the extended ID defined by SD_ANT_EXT0_ID_&lt;name&gt;</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pvArg0</td><td>is first argument to extended ANT SVC function specified by ucExtID</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pvArg1</td><td>is second argument to extended ANT SVC function specified by ucExtID</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pvArg2</td><td>is third argument to extended ANT SVC function specified by ucExtID</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return value(s) of extended ANT SVC function specified by ucExtID </dd></dl>

</div>
</div>
<a class="anchor" id="gadc8dd07669424ef4e30dfaa75fa00a82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_id_list_add </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>aucDevId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucListIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to add a Device ID to an include or exclude list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel number to add the list entry to.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aucDevId</td><td>is the pointer to the buffer (4 octets) containing device ID information with the following format: <pre class="fragment">       Byte0 = DeviceNumber_LSB

       Byte1 = DeviceNumber_MSB

       Byte2 = DeviceType

       Byte3 = TransType
</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucListIndex</td><td>is an unsigned char (1 octet) denoting the index where the specified Channel ID is to be placed in the list (0-3).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ERROR_INVALID_PARAM

     ::NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED

     ::NRF_ANT_ERROR_INVALID_LIST_ID</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="gaeaf8ece10c4b90f397fac9f760408c64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_id_list_config </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucIDListSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucIncExcFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to configure the device ID list as include or exclude as well as the number of IDs to compare against. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel number of the device ID list.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucIDListSize</td><td>is an unsigned char (1 octet) denoting the size of the inclusion or exclusion list (0-4).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucIncExcFlag</td><td>is an unsigned char (1 octet) denoting the type of list as Include(0) or Exclude(1)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED

     ::NRF_ANT_ERROR_INVALID_LIST_ID</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="ga67109fc1c0cb71cb88976d554ae3cd5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_lib_config_clear </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucANTLibConfig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function clears the ANT Messaging Library Configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucANTLibConfig</td><td>is an unsigned char (1 octet) denoting the ANT lib Config bit(s) to clear. See ANT Library Config in ant_parameters.h.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga5044f2aea53e57eb113fc8f4afd02b6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_lib_config_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pucANTLibConfig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns current ANT Messaging Library Configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pucANTLibConfig</td><td>is the pointer to an unsigned char (1 octet) where the bit flags will be stored. See ANT Library Config in ant_parameters.h.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ERROR_INVALID_PARAM</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="gaf75d7ef14fd9efe9fbad3f1892fd5c74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_lib_config_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucANTLibConfig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the ANT Messaging Library Configuration used by Extended messaging. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucANTLibConfig</td><td>is an unsigned char (1 octet) denoting the ANT lib config bit flags. See ANT Library Config in ant_parameters.h.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="ga485b80f454f617a6a611dd2161330295"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_network_address_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucNetwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>aucNetworkKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the 64bit network address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucNetwork</td><td>is an unsigned char (1 octet) denoting the network number to assign the network address to.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aucNetworkKey</td><td>is the pointer to location of the Network Key (8 octets in length)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ERROR_INVALID_PARAM

     ::NRF_ANT_ERROR_INVALID_NETWORK_NUMBER</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="ga2c0e2144ea9c33340c3ee660eef0ebec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_pending_transmit </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pucPending</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function determines if there is a pending transmission on a specific channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel number to query.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pucPending</td><td>is the pointer to an unsigned char (1 octet) where the pending result will be stored. 1 = pending, 0 = otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ERROR_INVALID_PARAM

     ::NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="ga93a4111cc6e4b75e3b6b4d665937e625"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_pending_transmit_clear </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pucSuccess</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function clears a pending transmit. Primarily intended for shared slave channels (receive channel). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel to clear pending transmit.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pucSuccess</td><td>is the pointer to an unsigned char (1 octet) where the result will be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ERROR_INVALID_PARAM

     ::NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="ga06b245376f5a6a1b1cc3eb747b12a245"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_prox_search_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucProxThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucCustomProxThreshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the sensitivity threshold for acquisition on a searching channel. One time set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel number.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucProxThreshold</td><td>is an unsigned char (1 octet) denoting the minimum RSSI threshold required for acquisition during a search. See Radio Proximity Search Threshold in ant_parameters.h</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucCustomProxThreshold</td><td>is an unsigned char (1 octet) denoting the custom minimum RSSI threshold for acquisition during a search. Only applicable if ucProxThreshold is set to custom proximity selection.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="gaa66114d4387791c8b4b20317698d6cb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_rfactive_notification_config_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pucMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>pusTimeThreshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function retrieves the ANT rf active notification configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pucMode</td><td>is a pointer to an unsigned char (1 octet) where the configured mode of event notification will be stored.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pusTimeThreshold</td><td>is a pointer to an unsigned short (2 octets) where the configured time threhold value will be stored. Time threshold is in 32 kHz counts (usTimeThreshold/32768 s).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ERROR_INVALID_PARAM</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="ga74d5df5b5e66bf6d40b283e80842c0c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_rfactive_notification_config_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>usTimeThreshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables/disables event notifications to be generated to the application indicating the time to the next ANT radio activity exceeds the configured time threshold. </p>
<pre class="fragment">     Latency (delay in event notification being received and processed by application) must be taken into account if attempting to use this generated event to perform

     operations prior to the radio activity. Cannot be used if asynchronous tx channel is assigned or used. Please note that this only generates events for ANT radio activity.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucMode</td><td>is an unsigned char (1 octet) denoting the mode of event notification. See RFActive Notification Defines in ant_parameters.h.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">usTimeThreshold</td><td>is an unsigned short (2 octets) denoting the minimum time threshold (32 kHz counts (usTimeThreshold/32768 s)) before the next radio activity that will trigger generation of the event notification.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED

     ::NRF_ANT_ERROR_CHANNEL_IN_WRONG_STATE</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="gaafafa38f71054778becea049bc3ada46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_rx_scan_mode_start </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucSyncChannelPacketsOnly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function starts receive scanning mode feature. Channel 0 must be assigned. All other channels must be closed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucSyncChannelPacketsOnly</td><td>is an unsigned char (1 octet) denoting synchronous channel only scanning mode. 0 = disable, 1 = enable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ANT_ERROR_CLOSE_ALL_CHANNELS

     ::NRF_ANT_ERROR_CHANNEL_IN_WRONG_STATE</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="ga23878b31b61d3314ed4a315a55afca90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_sdu_mask_config </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucMaskConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function assigns a SDU mask configuration to a particular channel. The configuration specifies the mask identifier and the type of rx data in which the mask should be applied to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel in which the SDU mask configuration is to be applied to.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucMaskConfig</td><td>is an unsigned char (1 octet) denoting SDU mask configuration. See Selective Data Update Mask Configuration Defines in ant_parameters.h.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="ga9b975a9f6539705f63863d11d8ca4f23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_sdu_mask_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>aucMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the selective data update (SDU) mask (8 octets) from the specified identifier, ucMask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucMask</td><td>is an unsigned char (1 octet) denoting the index representing the SDU data mask.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">aucMask</td><td>is a pointer to the buffer where the SDU data mask will be copied, the array should be at least 8 octects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ERROR_INVALID_PARAM

     ::NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="ga231d8b588e95f769b07b6fbdd879d439"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_sdu_mask_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>aucMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to assign a selective data update (SDU) mask (8 octets) to an identifier, ucMask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucMask</td><td>is an unsigned char (1 octet) denoting the index representing the SDU data mask.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aucMask</td><td>is a buffer (8 octets) containing the SDU mask to be assigned to ucMask.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ERROR_INVALID_PARAM

     ::NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="ga3020bbb168a16049a94e39f3742a96e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_search_channel_priority_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucSearchPriority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the channel's search priority. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel number to set.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucSearchPriority</td><td>is an unsigned char (1 octet) denoting the search priority value. 0 to 7 (Default = 0).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="gaf4de80c986c5f0be170c850ea50a639a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_search_waveform_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>usWaveform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the searching waveform value of an ANT Channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel number to set.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">usWaveform</td><td>is an unsigned short (2 octets) denoting the channel waveform period (usWaveform/32768 s). Default = 316.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</pre> </dd></dl>

</div>
</div>
<a class="anchor" id="ga38b44d71b463cfd0d12fa07b63191d9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_stack_reset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for initializing or re-initializing ANT Stack. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga59fb0d7717ce7e81a0adecd247511b17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_transfer_stop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function kills a receive transfer that is in progress. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga529f053ac81ed70c97ade5a8ee7ddb4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_version_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>aucVersion</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the version string of the ANT stack. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">aucVersion</td><td>is the pointer to the buffer where the version string will be copied, the array should be at least 11 octets.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00385.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <pre class="fragment">     ::NRF_ERROR_INVALID_PARAM</pre> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu May 7 2015 14:37:17 for nRF51 SDK - S210 SoftDevice by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.3.1 </li>
  </ul>
</div>
</body>
</html>
