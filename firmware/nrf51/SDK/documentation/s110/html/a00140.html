<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>nRF51 SDK - S110 SoftDevice: Gazell Link Layer User Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="nordic_small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">nRF51 SDK - S110 SoftDevice
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>API&#160;Reference</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a00140.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Gazell Link Layer User Guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#gzll_intro">Introduction</a></li>
<li class="level1"><a href="#features">Features</a></li>
<li class="level1"><a href="#gzll_resources">Resources</a></li>
<li class="level1"><a href="#modes">Gazell modes</a></li>
<li class="level1"><a href="#getting_started">Setting up a Gazell application</a></li>
<li class="level1"><a href="#package_transaction">Package transactions</a></li>
<li class="level1"><a href="#packet_id">Packet identification</a><ul><li class="level2"><a href="#addressing">Pipes and addressing</a></li>
</ul>
</li>
<li class="level1"><a href="#FIFOs">FIFOs</a><ul><li class="level2"><a href="#dev_fifo">Device FIFO handling</a></li>
<li class="level2"><a href="#host_fifo">Host FIFO handling</a></li>
</ul>
</li>
<li class="level1"><a href="#callback_queueing">Callback queueing</a></li>
<li class="level1"><a href="#timeslot">Timeslots</a></li>
<li class="level1"><a href="#freq">Frequency hopping</a></li>
<li class="level1"><a href="#synchronization">Synchronization</a></li>
<li class="level1"><a href="#gzll_backwards">Backwards compatibility</a><ul><li class="level2"><a href="#gzll_bw_channels">Channel tables</a></li>
<li class="level2"><a href="#gzll_bw_timeslots">Timeslot periods</a></li>
<li class="level2"><a href="#gzll_bw_emulation">Emulating legacy Gazell modes</a><ul><li class="level3"><a href="#gzll_bw_emulation_dev_mode_2">Emulating legacy nRF24Lxx Gazell Device mode 2 and nRF24Lxx Host mode 0.</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="gzll_intro"></a>
Introduction</h1>
<p>Gazell is a protocol for setting up a robust wireless link between a single Host and up to eight Devices in a star network topology. It is designed to minimize power consumption in power-sensitive wireless desktop products and is also suitable for a range of other wireless applications.</p>
<p>To minimize the power consumption of the power-sensitive peripheral devices, Gazell uses the central hub (host side) with its more relaxed power constraints to keep the link open while the peripheral devices can sleep and save on power consumption. A typical example of this is a wireless mouse communicating with a USB dongle that is inserted into a computer.</p>
<p>Gazell has a sophisticated but easy-to-use channel switching and synchronization scheme, that gives robustness against interference and good wireless coexistence properties while still enabling high-throughput and low latency.</p>
<h1><a class="anchor" id="features"></a>
Features</h1>
<ul>
<li>Supports a star network topology with one Host and up to 8 Devices.</li>
<li>Bi-directional data transfer between each Host and Device.</li>
<li>Channel hopping functionality that gives a reliable wireless link in environments with interference from other radio sources.</li>
<li>Packet acknowledgement and automatic packet retransmission functionality to prevent data loss.</li>
<li>Individual TX and RX FIFOs for every data pipe.</li>
<li>Backward compatible with legacy nRF24L Series Gazell.</li>
<li>Devices self-synchronize to the Host, meaning:<ul>
<li>No connection packets are required to setup a link.</li>
<li>No polling packets are required to maintain a link.</li>
<li>Devices can enter and remove themselves from the network at any time.</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="gzll_resources"></a>
Resources</h1>
<p>Gazell makes use of a fixed set of resources and requires exclusive access to them for Gazell to ensure correct operation. There are two options for what set of resources to be used:</p>
<ol type="1">
<li>gzll_arm.lib</li>
</ol>
<ul>
<li>Radio (NRF_RADIO)</li>
<li>Timer: NRF_TIMER2)</li>
<li>PPI channels 0, 1, and 2</li>
<li>Software interrupt 0</li>
</ul>
<ol type="1">
<li>gzll_sd_resources_arm.lib (reusing the same resources used by the S1xx Bluetooth Smart softdevice library from Nordic):</li>
</ol>
<ul>
<li>Radio (NRF_RADIO)</li>
<li>Timer: NRF_TIMER0)</li>
<li>PPI Channels 8, 9, and 10</li>
<li>Software interrupt 1</li>
</ul>
<p>The radio and timer interrupt handlers run at priority level 0 (highest level), and the Gazell callback functions run at priority level 1. Applications should run at priority level 2 or higher in order to ensure correct operation.</p>
<p>Gazell can be customized at runtime for a range of different applications. See the <a class="el" href="a01191.html">Gazell Link Layer</a> for a list of configuration functions as well as the default and constant parameters.</p>
<p><b>Note:</b> Editing the header file containing the default and constant parameters does not change their value when compiling a new project. These values are provided as a useful reference when making an application with the precompiled library.</p>
<h1><a class="anchor" id="modes"></a>
Gazell modes</h1>
<p>A member of a Gazell star network is either a Host or Device. Up to 8 Devices can communicate with a single Host. Each Host can communicate with up to 8 Devices. Each Device communicates to a single Host.</p>
<div class="image">
<img src="gzll_fig1_star_network.png" alt="gzll_fig1_star_network.png"/>
<div class="caption">
Gazell star network</div></div>
<p>Once enabled, the Host in a Gazell network is always listening, and it is the Device that always initiates a communication. Each packet that a Device sends is required to be acknowledged by the Host. It is possible for the Host to send data to the Device by piggybacking data to an acknowledgement (ACK) packet. Therefore a Host has to wait for a packet from a Device before it can send any data to it.</p>
<p>It is possible to build more sophisticated Gazell networks, since a single Device is able to speak to several Hosts and any node is able to change between the two modes. However, this requires the application to coordinate such a network.</p>
<p>In this document, we focus here on the typical use-case as a star network with static modes.</p>
<h1><a class="anchor" id="getting_started"></a>
Setting up a Gazell application</h1>
<p>Gazell automatically handles all synchronization and packet handling. All the user is required to do is to add payloads to the transmit (TX) FIFOs and read payloads from the receive (RX) FIFOs. Gazell automatically notifies the application when a packet is received.</p>
<p>To set up a Gazell application, do the following:</p>
<ul>
<li>Initialize Gazell using <a class="el" href="a01191.html#gacba07d9c893b4673c563ced97cccba94" title="Initialize Gazell.">nrf_gzll_init()</a> and choose either Host or Device.</li>
<li>Reconfigure Gazell's default parameters. At a minimum the addresses and channels should be reconfigured to avoid interfering with other Gazell networks.</li>
<li>Enable Gazell using <a class="el" href="a01191.html#gadfb1003b245b019481334e6d087f928e" title="Enable Gazell.">nrf_gzll_enable()</a>.</li>
<li>If the node is a Device, start sending:<ul>
<li>Add payloads to the TX FIFO using <a class="el" href="a01191.html#ga1c0b1d1838e032af28c35d7c3e0603e0" title="Add a packet to the tail of the TX FIFO.">nrf_gzll_add_packet_to_tx_fifo()</a>.</li>
<li>Handle the returned ACK packet when the <a class="el" href="a01191.html#gac1306762dc2ccfc5c2bbdbe2d85a93aa" title="ACK received callback (Device mode only).">nrf_gzll_device_tx_success()</a> callback is called. Fetch the payloads from the RX FIFO using <a class="el" href="a01191.html#ga419c8ce6a3e08d5dec8b50ef88b3cc2b" title="Fetch a packet from the head of the RX FIFO.">nrf_gzll_fetch_packet_from_rx_fifo()</a>.</li>
<li>Handle the failed packet transmissions when the <a class="el" href="a01191.html#ga0642fed399ed3ec41406cd4323edf5ad" title="Transmission failed callback (Device mode only).">nrf_gzll_device_tx_failed()</a> callback is called. Failed packets are automatically removed from the TX FIFO.</li>
</ul>
</li>
<li>If the node is a Host, start listening:<ul>
<li>Handle the received data packets when the nrf_gzll_host_packet_received() calbback is called. Fetch the packets from the RX FIFO using nrf_gzll_fetch_from_rx_firo().</li>
<li>Add any payloads to send to the TX FIFO using <a class="el" href="a01191.html#ga1c0b1d1838e032af28c35d7c3e0603e0" title="Add a packet to the tail of the TX FIFO.">nrf_gzll_add_packet_to_tx_fifo()</a>.</li>
</ul>
</li>
</ul>
<p>Gazell can also be disabled at any time using the <a class="el" href="a01191.html#ga20e0e3ca35dda6b9220b1ddce7565687" title="Disable Gazell.">nrf_gzll_disable()</a> function. When this is called Gazell will complete any ongoing transmission or reception before being disabled. (That is, until the end of the current timeslot, a concept we explain later in the section on <a class="el" href="a00140.html#timeslot">Timeslots</a>). When the disabling operation is complete, Gazell will call the <a class="el" href="a01191.html#ga722e2ee917072fca60a50a23d8c84414" title="Disabled callback.">nrf_gzll_disabled()</a> function. By the time this callback is made, the Gazell CPU context, radio and Gazell timer will have stopped. It is now possible to call any of the configuration set functions, which will be in force, once Gazell is enabled again.</p>
<h1><a class="anchor" id="package_transaction"></a>
Package transactions</h1>
<p>A typical packet transaction between a Device and a Host consists of a Device initiating the transaction by sending a data packet to the Host and the Host sending an ACK packet in return.</p>
<p>When an ACK packet is received by the Device, it knows that the initial packet was successfully transmitted and the <a class="el" href="a01191.html#gac1306762dc2ccfc5c2bbdbe2d85a93aa" title="ACK received callback (Device mode only).">nrf_gzll_device_tx_success()</a> callback function will be called to notify the application of this.</p>
<p>Similarly, when the initial packet is received by the Host, the <a class="el" href="a01191.html#ga116b8ce684c3f6fe8c63c371b913aa3e" title="Data packet received callback (Host mode only).">nrf_gzll_host_rx_data_ready()</a> callback function will be called to notify to the application that a new packet has been received.</p>
<p>Note that these callback functions are actually queued so that the application avoids race conditions. This is discussed later in the section <a class="el" href="a00140.html#callback_queueing">Callback queueing</a>.</p>
<div class="image">
<img src="gzll_fig7_host_dev_trans_ok.png" alt="gzll_fig7_host_dev_trans_ok.png"/>
<div class="caption">
Successful packet transaction</div></div>
<p>A transaction can fail if the initial packet from the Device was not received correctly by the Host, or the corresponding ACK packet was not received correctly by the Device. Note that packets with a failing Cyclic Redundancy Check (CRC) are ignored by Gazell.</p>
<p>If a transaction fails the Device will attempt to retransmit the initial packet to the Host until the ACK is finally received or the maximum number of transmission attempts is reached. If the maximum number of transmission attempts is reached the retransmissions will stop and the <a class="el" href="a01191.html#ga0642fed399ed3ec41406cd4323edf5ad" title="Transmission failed callback (Device mode only).">nrf_gzll_device_tx_failed()</a> callback will be called.</p>
<p>If only the ACK packet sent from the Host to the Device is lost, but both the initial packet and the subsequent retransmission attempts are being successfully received by the Host, the repeated packets will be discarded by the Host, but the ACK packets will still be sent in return to the Device. This prevents the application receiving duplicate data packets at the Host.</p>
<div class="image">
<img src="gzll_fig8_host_dev_trans_fail.png" alt="gzll_fig8_host_dev_trans_fail.png"/>
<div class="caption">
Example on failing package transaction.</div></div>
<p>In the figure above the maximum number of allowed transmission attempts is set to 3.</p>
<h1><a class="anchor" id="packet_id"></a>
Packet identification</h1>
<p>Any packet transmitted from a Device to a Host is uniquely identified by a two bit packet ID field in the packet header together with the packet's 16-bit Cyclic Redundancy Check (CRC). This packet ID is used to distinguish a new packet from the previous packet if it has the same payload.</p>
<p>On the Host side, retransmitted packets will be discarded and not added to an RX FIFO.</p>
<h2><a class="anchor" id="addressing"></a>
Pipes and addressing</h2>
<p>Each logical address on the nodes is termed a pipe. Each pipe maps to one on-air address used when transmitting or receiving packets.</p>
<p>The on-air addresses are composed of a 2-4 byte long "base address" in addition to a 1 byte prefix address. Note that the nRF51 radio uses an alternating sequence of 0s and 1s as the preamble of the packet. Therefore, for packets to be received correctly, the most significant byte of the base address should not be an alternating sequence of 0s and 1s, that is, it should not be 0x55 or 0xAA.</p>
<p>Pipe 0 has its own unique base address, which is base address 0, while pipes 1-7 use the same base address, which is base address 1.</p>
<p>Each of the 8 pipes have a unique byte-long prefix address.</p>
<p>On-air, the most significant bit of each address byte will be transmitted first. The most significant byte of the 4 byte long base address is the first transmitted address byte, while the prefix byte is transmitted last.</p>
<p>Note: The byte ordering in Gazell and the nRF51 radio peripheral are not the same, this is because the address bytes are rearranged in Gazell to match the nRF24L radios.</p>
<h1><a class="anchor" id="FIFOs"></a>
FIFOs</h1>
<p>All 8 pipes on both the Device and the Host have two First-in First-out (FIFO) buffers that can hold packets. Each pipe has a TX FIFO and an RX FIFO. The total number of packets in the FIFOs is 6, while every individual TX or RX FIFO (8 pipes x 2 = 16 in total) can store 3 packets.</p>
<h2><a class="anchor" id="dev_fifo"></a>
Device FIFO handling</h2>
<p>When Gazell is enabled in Device mode, any packets uploaded to a TX FIFO will be transmitted at the next opportunity. If several TX FIFOs contain packets, the various TX FIFOs will be serviced in a round robin fashion, meaning that no TX FIFOs will experience starvation even when packets are continuously being added to other TX FIFOs.</p>
<p>When an ACK is successfully received from a Host, it implies that the payload was successfully received and added to the Host's RX FIFO, the successfully transmitted packet will be removed from the TX FIFO so that the next packet in the FIFO can be transmitted.</p>
<p>If an ACK received by a Device contains a payload, this payload will be added to the pipe's RX FIFO.</p>
<p>If the RX FIFO for a specific pipe on a Device is full and can not accommodate any new packets, no new packets will be sent from the Device on this pipe. In this case, we will never end up in the situation where a payload received in an ACK will have to be discarded due to the pipe's RX FIFO being full.</p>
<h2><a class="anchor" id="host_fifo"></a>
Host FIFO handling</h2>
<p>When Gazell is enabled in Host mode, all enabled pipes (addresses) are simultaneously monitored for incoming packets.</p>
<p>If a new packet not previously added to the pipe's RX FIFO is received, and the pipe's RX FIFO has available space for the packet, the packet will be added to the RX FIFO and an ACK will be sent in return to the Device. If the pipe's TX FIFO contains any packets, the next serviceable packet in the TX FIFO will be attached as a payload in the ACK packet. In order for a TX packet to be attached to an ACK, this TX packet would have to be uploaded to the TX FIFO before the packet is received.</p>
<p>Since the ACK will not always be successfully received by the Device, the data payload added to the ACK will not be removed from the TX FIFO immediately. This TX packet will be removed from the TX FIFO when a new packet (new packet ID or CRC) is received on the same pipe. In this case, the new packet sent from the Device serves as an acknowledgement of the ACK sent previously by the Host. ACKs sent in reply to retransmission attempts contain the same TX payload.</p>
<p>When the Host is handling packets on multiple pipes, care needs to be taken to ensure that ACK payloads in the TX FIFOs on pipes that are no longer in use, are not taking up space in the memory pool and consequently blocking communication on other pipes. To avoid such congestion, the application on the Host can flush the TX FIFOs on the pipes no longer in use.</p>
<h1><a class="anchor" id="callback_queueing"></a>
Callback queueing</h1>
<p>Gazell contains an internal callback queue for queueing pending callbacks when Gazell attempts to call a new callback function while the application is already servicing a previously called callback function.</p>
<p>As an example, if a new packet is being received by a Host while the application is already servicing the <a class="el" href="a01191.html#ga116b8ce684c3f6fe8c63c371b913aa3e" title="Data packet received callback (Host mode only).">nrf_gzll_host_rx_data_ready()</a> callback from a previously received packet, the <a class="el" href="a01191.html#ga116b8ce684c3f6fe8c63c371b913aa3e" title="Data packet received callback (Host mode only).">nrf_gzll_host_rx_data_ready()</a> callback for the latest packet will be added to the callback queue and serviced at a later opportunity. In this case, <a class="el" href="a01191.html#ga116b8ce684c3f6fe8c63c371b913aa3e" title="Data packet received callback (Host mode only).">nrf_gzll_host_rx_data_ready()</a> will be called one time for every received packet, and the application does not need to handle the potential race condition scenario where a new packet is being received just before the application is about to exit the <a class="el" href="a01191.html#ga116b8ce684c3f6fe8c63c371b913aa3e" title="Data packet received callback (Host mode only).">nrf_gzll_host_rx_data_ready()</a> function.</p>
<p>Similarly, on a Device the <a class="el" href="a01191.html#gac1306762dc2ccfc5c2bbdbe2d85a93aa" title="ACK received callback (Device mode only).">nrf_gzll_device_tx_success()</a> callback will be called one time for every packet receiving an ACK, even when a new packet is receiving an ACK while the application is servicing the <a class="el" href="a01191.html#gac1306762dc2ccfc5c2bbdbe2d85a93aa" title="ACK received callback (Device mode only).">nrf_gzll_device_tx_success()</a> callback of a previously transmitted packet.</p>
<p>The size of the callback queue is given by NRF_GZLL_CONST_CALLBACK_QUEUE_LENGTH.</p>
<h1><a class="anchor" id="timeslot"></a>
Timeslots</h1>
<p>A core parameter in Gazell is the <b>timeslot</b>. The timeslot can be seen as the internal Gazell "heartbeat".</p>
<p>In a Device, any packet transmission (both new packets and retransmitted packets) will start at the start of a timeslot, and only one packet transaction (including ACK) can take place within a timeslot.</p>
<div class="image">
<img src="gzll_fig2_device_heartbeat.png" alt="gzll_fig2_device_heartbeat.png"/>
<div class="caption">
Relation between Device operation and timeslot</div></div>
<p>Similarly on the Host side, the radio initiates a radio startup at the start of the timeslot to start listening. In addition, it may optionally change the RF channel it listens on.</p>
<div class="image">
<img src="gzll_fig3_host_heartbeat.png" alt="gzll_fig3_host_heartbeat.png"/>
<div class="caption">
Relation between Host operation and timeslot</div></div>
<p>The period for the heartbeat is set using the <a class="el" href="a01191.html#ga3347094a64c07793c773c4fdf4bc4bff" title="Set the timeslot period.">nrf_gzll_set_timeslot_period()</a> function.</p>
<h1><a class="anchor" id="freq"></a>
Frequency hopping</h1>
<p>To ensure good coexistence performance with other radio products operating in the same 2.4 GHz frequency band as Gazell, such as Wi-Fi or <em>Bluetooth</em>, Gazell implements mechanisms for hopping between various radio frequency channels.</p>
<p>When enabled, Gazell will pick channels from a predefined channel table.</p>
<p>The contents and size of this channel table can be reconfigured by the application, however the Device and Host must be configured to have the exact same channel table. In total the application can pick from a full channel set of 80 channels when specifying the channel table. Normally, a channel table of 3-7 channels has shown to give a satisfactory coexistence performance in most environments.</p>
<p>Having a too large channel table may increase the transmission latency and power consumption, while using a too small channel table may decrease the coexistence performance.</p>
<p>The core parameters deciding the channel hopping behavior are:</p>
<ul>
<li><b>timeslots_per_channel</b> (Applies for Host and "in sync" Device, set by <a class="el" href="a01191.html#gaf636a5a1aa2d4a791849de510b69a604" title="Set the number of timeslots that Gazell shall reside on a single channel before switching to another ...">nrf_gzll_set_timeslots_per_channel()</a>).</li>
<li><b>timeslots_per_channel_when_device_out_of_sync</b> (Applies for "out of sync" Device only, set by <a class="el" href="a01191.html#ga8a1bef2e6f32bd8dc55e9abde3007aed" title="Set the number of timeslots that a Gazell shall reside on a single channel before switching to anothe...">nrf_gzll_set_timeslots_per_channel_when_device_out_of_sync()</a>).</li>
<li><b>channel_selection_policy</b> (Applies for "in sync" Device only, set by <a class="el" href="a01191.html#ga692ed4d88a064fdf9a4e69f939582911" title="Set the Device channel selection policy.">nrf_gzll_set_device_channel_selection_policy()</a>).</li>
</ul>
<p>Which one being used depends on whether Gazell is "in sync" or "out of sync" (these terms are described in the <a class="el" href="a00140.html#synchronization">Synchronization</a> section). Therefore, we will not differentiate between these two terms and use the term <b>timeslots_per_channel</b> instead.</p>
<p>The <b>timeslots_per_channel</b> parameter decides the number of timeslots Gazell resides on a single channel before the channel is changed. When the next timeslot where a channel shift is performed, Gazell will pick the next channel from the predefined channel table, cycling back to the start of the channel table if required.</p>
<div class="image">
<img src="gzll_fig4_device_channel_switch.png" alt="gzll_fig4_device_channel_switch.png"/>
<div class="caption">
Host and Device channel switching. Here, <b>timeslots_per_channel</b> = 2.</div></div>
<p>Note: Host channel switching is the same as Device channel switching.</p>
<p>In Device mode, <b>timeslots_per_channel</b> can also be seen as the number of transmission attempts to be spent on each channel before switching channel. This is because there is at most one transmission attempt for every timeslot.</p>
<p>The <b>channel_selection_policy</b> parameter is used by a Device being in sync to decide the initial channel to be used when sending a new packet to a Host (that is, for the first time the new packet is sent, not for the retransmission attempts).</p>
<p>Once synchronized with the Host, the Device can send either on the current channel that it believes the Host is on or on the last successful channel. This can be configured using the <a class="el" href="a01191.html#ga692ed4d88a064fdf9a4e69f939582911" title="Set the Device channel selection policy.">nrf_gzll_set_device_channel_selection_policy()</a>.</p>
<p>This <b>channel_selection_policy</b> parameter can take the following two values:</p>
<ul>
<li><a class="el" href="a01191.html#ggad45683bddfd8a170f89280b722f7744ca7ac745d687a1dc56962bed8a98ba719f">NRF_GZLL_DEVICE_CHANNEL_SELECTION_POLICY_USE_SUCCESSFUL</a></li>
<li><a class="el" href="a01191.html#ggad45683bddfd8a170f89280b722f7744ca97b439d85d2666cb9676c45f0db57a55">NRF_GZLL_DEVICE_CHANNEL_SELECTION_POLICY_USE_CURRENT</a></li>
</ul>
<p>By choosing the <a class="el" href="a01191.html#ggad45683bddfd8a170f89280b722f7744ca7ac745d687a1dc56962bed8a98ba719f">NRF_GZLL_DEVICE_CHANNEL_SELECTION_POLICY_USE_SUCCESSFUL</a> policy, the Device will start sending packets on the channel it last had a successfully acknowledged transmission. This policy is the most robust against static interferers as once the Device finds a quiet channel it should be able to continue using this quiet channel.</p>
<p>By choosing the <a class="el" href="a01191.html#ggad45683bddfd8a170f89280b722f7744ca97b439d85d2666cb9676c45f0db57a55">NRF_GZLL_DEVICE_CHANNEL_SELECTION_POLICY_USE_CURRENT</a> policy, the Device sends on the channel it believes the Host is currently listening to. This achieves the lowest latency and highest throughput of the two policies as the Device does not have to wait for the Host to be listening on a specific channel. This policy is frequency hopping. The disadvantage of this policy is that if there is a static interferer on a particular channel, the Device will waste packets attempting to send on this channel. Note that the application can reconfigure the channel table during runtime to overcome this.</p>
<p>As mentioned, the channel selection policy only applies for the initial transmitted packet. If transmission of this initial packet fails, the following retransmission attempts will always be sent at the channel the Device believes the Host is monitoring.</p>
<p>If Gazell is "out of sync", Gazell will always start the packet transmission immediately using the previous successful transmission channel. If Gazell has never before transmitted a successful packet and thus has no "previous successful channel" to relate to, Gazell will start using the first channel in the channel table.</p>
<h1><a class="anchor" id="synchronization"></a>
Synchronization</h1>
<p>The internal timeslot, or "heartbeat", mechanism of Gazell is used to obtain synchronous communication while still enabling efficient channel switching. This mechanism is useful when a Device needs to switch to a new channel in the case when radio interference is being experienced on the current channel.</p>
<p>Each Gazell Device has two synchronization states: "in sync" and "out of sync".</p>
<p>On the Host, the internal "heartbeat" timer will always be running when Gazell is enabled, independent of the Devices' synchronization state.</p>
<p>On the Device, the "heartbeat" timer will only run as long as the Device is "in sync" or as long as there are packets to be sent. If the timer has been stopped and packets are added to a TX FIFO, the timer will be started immediately.</p>
<p>Before any packets have been successfully received and acknowledged, the Device is out of sync. In this state, the Device switches channel determined by the <b>timeslots_per_channel_when_device_out_of_sync</b>. The Device switches channel at a slower rate than the Host (as determined by <b>timeslots_per_channel</b>) so that the Device will eventually transmit a packet on the same channel that the Host is on.</p>
<p>When a Device successfully transmits a packet, that is when an ACK packet is received from the Host, the Device will enter "in sync" state, as it now has the information needed for continuing to "guess" the following channels the Host will be listening to.</p>
<p>For knowing when to change channel, Gazell has an internal <b>timeslot_counter</b> to count the number of timeslots Gazell resides on a single channel. When this counter reaches <b>timeslots_per_channel</b>, the <b>timeslot_counter</b> is reset and the <b>channel_index</b> is incremented (cyclically). When an ACK is received, the Device knows the current channel being used by the Host, but it can not know the <b>timeslot_counter</b> state on the Host. As a result, it is only for the timeslots where the <b>timeslot_counter</b> equals zero a Device can be confident that it "guesses" the correct channel that a Host is monitoring. Therefore, when an ACK is received, the timeslot_counter for the current timeslot is reset to 0, and a new Device transmission start when the <b>timeslot_index</b> counter on the Device is zero. Retransmission attempts, however, are sent on all timeslots</p>
<p>Once the Device is in sync it will keep an internal timer running in order to maintain the internal heartbeat in order to remain synchronized with the Host. The duration that the Device will stay in the in sync state is the <b>sync_lifetime</b> and is measured in timeslots. The <b>sync_lifetime</b> is reset whenever a packet is received. Once the <b>sync_lifetime</b> has expired on a Device, the internal timer is stopped and the Device returns to out of sync behavior.</p>
<p>Note that, whenever a Device that is "in sync" sends a packet but does not receive an ACK it will continue transmitting maximum number of transmit attempts are reached.</p>
<p>By setting the <b>sync_lifetime</b> to zero, the Device will never be in sync. The <b>sync_lifetime</b> should be chosen with regard to how often packets are required to be sent and the fact that synchronization can only be maintained for a finite time due to clock drift and radio interference. The sync lifetime is configured using <a class="el" href="a01191.html#ga1b34f8db6bfac6c6e232c2767a260bf3" title="Set the number of timeslots after a successful reception of a Device or Host packet that the Gazell L...">nrf_gzll_set_sync_lifetime()</a>.</p>
<p>The Device can know that sync has been achieved when the number of retransmissions gets close to zero. The <a class="el" href="a00445.html" title="Data structure containing information about the last packet transmission.">nrf_gzll_device_tx_info_t</a> structure is passed to the Device callback functions, and contains the number of transmit attempts required for the current packet. In addition, the <a class="el" href="a00445.html" title="Data structure containing information about the last packet transmission.">nrf_gzll_device_tx_info_t</a> contains the <b>num_channel_switches</b> parameter which can be used by the application to determine whether the RF channels are reliable. This would make it possible for the application to track bad channels and update the channel tables on Host and Device if desired.</p>
<h1><a class="anchor" id="gzll_backwards"></a>
Backwards compatibility</h1>
<p>The Gazell Link Layer examples are not fully "out of the box" compatible with the legacy Gazell examples provided in the nRFgo SDK for nRF24Lxx devices. The default timeslot period and channel tables require adjustment, as well some setup to emulate the Gazell modes. Note that the Gazell "Low Power Host mode" (Host mode 1) is not supported in the nRF51.</p>
<h2><a class="anchor" id="gzll_bw_channels"></a>
Channel tables</h2>
<p>The default channel tables require adjustment.</p>
<p>To change these values:</p>
<ul>
<li>Edit gzll_params.h file used in the nRF24Lxx projects, or</li>
<li>Use the <a class="el" href="a01191.html#ga1aa10efb06cf0cd2a5b197a4cd65deaa" title="Set the table of Radio Frequency (RF) channels.">nrf_gzll_set_channel_table()</a> function in the nRF51 projects.</li>
</ul>
<h2><a class="anchor" id="gzll_bw_timeslots"></a>
Timeslot periods</h2>
<p>The Gazell Link Layer supports the following minimum timeslot periods.</p>
<ul>
<li>600us timeslot period, nRF51 Gazell Device to nRF51 Gazell Host.</li>
<li>504us timeslot period, nRF51 Gazell Device to nRF24Lxx Gazell Host.</li>
</ul>
<p>When using 504 us timeslot period, the following restrictions apply:</p>
<ul>
<li>Max payload size is 17 bytes</li>
<li>Max ack payload size is 10 bytes</li>
</ul>
<p>In addition, the relation between the Device and Host timing parameters should be as follows:</p>
<ul>
<li>The Host listens to each channel in a <b>GZLL_RX_PERIOD</b> number of microseconds, where <b>GZLL_RX_PERIOD</b> is the heartbeat interval in the nRF24Lxx devices.</li>
<li>This Host <b>GZLL_RX_PERIOD</b> must be greater than the time required committing 2 full transmission attempts on the Device (including ACK wait time).</li>
</ul>
<p>To change these values:</p>
<ul>
<li>Edit gzll_params.h file used in the nRF24Lxx projects, or</li>
<li>Use the <a class="el" href="a01191.html#ga3347094a64c07793c773c4fdf4bc4bff" title="Set the timeslot period.">nrf_gzll_set_timeslot_period()</a> function in the nRF51 projects (i.e., nRF51 Gazell timeslot period = 0.5*GZLL_RX_PERIOD).</li>
</ul>
<h2><a class="anchor" id="gzll_bw_emulation"></a>
Emulating legacy Gazell modes</h2>
<p>The Gazell Link Layer protocol for the nRF51 series is compatible with the most useful modes of the Gazell Link Layer for the nRF24Lxx devices.</p>
<h3><a class="anchor" id="gzll_bw_emulation_dev_mode_2"></a>
Emulating legacy nRF24Lxx Gazell Device mode 2 and nRF24Lxx Host mode 0.</h3>
<p>The legacy "Device mode 2" can be emulated as follows:</p>
<ul>
<li>The channel selection policy is equivalent to <a class="el" href="a01191.html#ggad45683bddfd8a170f89280b722f7744ca7ac745d687a1dc56962bed8a98ba719f">NRF_GZLL_DEVICE_CHANNEL_SELECTION_POLICY_USE_SUCCESSFUL</a></li>
<li>When Gazell is "out of sync" a large number of attempts may occur on each channel before the channel is switched.</li>
<li>When Gazell is "in sync", a low number of transmission attempts, typically 2, are allowed on each channel before the channel is switched.</li>
</ul>
<p>The legacy "Host mode 0" has the following behavior:</p>
<ul>
<li>Host is always on while it is enabled.</li>
<li>When enabled, the Host will continuously cycle through the channel table.</li>
</ul>
<p>This behavior can be obtained the using the code snippet below. Here, we assume we have a channel table my_channel_table[] containing 3 channels.</p>
<p>This can be achieved using the following code snippet on the Device: </p>
<div class="fragment"><div class="line"><span class="comment">/* On Host and Device */</span></div>
<div class="line">timeslots_per_channel = 2;</div>
<div class="line">channel_table_size = 3;</div>
<div class="line"><a class="code" href="a01191.html#ga3347094a64c07793c773c4fdf4bc4bff" title="Set the timeslot period.">nrf_gzll_set_timeslot_period</a>(GZLL_RX_PERIOD / 2);</div>
<div class="line"><a class="code" href="a01191.html#ga1aa10efb06cf0cd2a5b197a4cd65deaa" title="Set the table of Radio Frequency (RF) channels.">nrf_gzll_set_channel_table</a>(my_channel_table, channel_table_size);</div>
<div class="line"><a class="code" href="a01191.html#gaf636a5a1aa2d4a791849de510b69a604" title="Set the number of timeslots that Gazell shall reside on a single channel before switching to another ...">nrf_gzll_set_timeslots_per_channel</a>(timeslots_per_channel);</div>
<div class="line"><span class="comment">/* On the Device */</span></div>
<div class="line"><a class="code" href="a01191.html#ga8a1bef2e6f32bd8dc55e9abde3007aed" title="Set the number of timeslots that a Gazell shall reside on a single channel before switching to anothe...">nrf_gzll_set_timeslots_per_channel_when_device_out_of_sync</a>(channel_table_size*timeslots_per_channel);</div>
<div class="line"><a class="code" href="a01191.html#ga692ed4d88a064fdf9a4e69f939582911" title="Set the Device channel selection policy.">nrf_gzll_set_device_channel_selection_policy</a>(<a class="code" href="a01191.html#ggad45683bddfd8a170f89280b722f7744ca7ac745d687a1dc56962bed8a98ba719f" title="Start on previous successful channel.">NRF_GZLL_DEVICE_CHANNEL_SELECTION_POLICY_USE_SUCCESSFUL</a>)</div>
</div><!-- fragment --><div class="image">
<img src="gzll_fig9_gzll_config_example.png" alt="gzll_fig9_gzll_config_example.png"/>
<div class="caption">
Emulating legacy Gazell</div></div>
 </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="a00005.html">User Guides</a></li>
    <li class="footer">Generated on Thu May 7 2015 14:36:28 for nRF51 SDK - S110 SoftDevice by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.3.1 </li>
  </ul>
</div>
</body>
</html>
