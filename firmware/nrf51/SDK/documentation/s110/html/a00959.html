<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>nRF51 SDK - S110 SoftDevice: Persistent Storage Access Routines</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="nordic_small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">nRF51 SDK - S110 SoftDevice
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>API&#160;Reference</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a00959.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Persistent Storage Access Routines<div class="ingroups"><a class="el" href="a00956.html">Persistent Storage Interface</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Functions/Interface SDK modules use to persistently store data.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga729ef8b64fc0cb6bfdabb2543a565d32"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00959.html#ga729ef8b64fc0cb6bfdabb2543a565d32">pstorage_init</a> (void)</td></tr>
<tr class="memdesc:ga729ef8b64fc0cb6bfdabb2543a565d32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Module Initialization Routine.  <a href="#ga729ef8b64fc0cb6bfdabb2543a565d32">More...</a><br/></td></tr>
<tr class="separator:ga729ef8b64fc0cb6bfdabb2543a565d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a57b964c8945eaca2d267835ef6688c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00959.html#ga0a57b964c8945eaca2d267835ef6688c">pstorage_register</a> (<a class="el" href="a00453.html">pstorage_module_param_t</a> *p_module_param, pstorage_handle_t *p_block_id)</td></tr>
<tr class="memdesc:ga0a57b964c8945eaca2d267835ef6688c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register with persistent storage interface.  <a href="#ga0a57b964c8945eaca2d267835ef6688c">More...</a><br/></td></tr>
<tr class="separator:ga0a57b964c8945eaca2d267835ef6688c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdeeb475e4f2db19863226bc55d507b5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00959.html#gafdeeb475e4f2db19863226bc55d507b5">pstorage_block_identifier_get</a> (pstorage_handle_t *p_base_id, pstorage_size_t block_num, pstorage_handle_t *p_block_id)</td></tr>
<tr class="memdesc:gafdeeb475e4f2db19863226bc55d507b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get block id with reference to base block identifier provided at time of registration.  <a href="#gafdeeb475e4f2db19863226bc55d507b5">More...</a><br/></td></tr>
<tr class="separator:gafdeeb475e4f2db19863226bc55d507b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12e52da12709de8d43bfb8389b80af6d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00959.html#ga12e52da12709de8d43bfb8389b80af6d">pstorage_store</a> (pstorage_handle_t *p_dest, uint8_t *p_src, pstorage_size_t size, pstorage_size_t offset)</td></tr>
<tr class="memdesc:ga12e52da12709de8d43bfb8389b80af6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routine to persistently store data of length 'size' contained in 'p_src' address in storage module at 'p_dest' address; Equivalent to Storage Write.  <a href="#ga12e52da12709de8d43bfb8389b80af6d">More...</a><br/></td></tr>
<tr class="separator:ga12e52da12709de8d43bfb8389b80af6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0316f640da7481e9bd03ed51b29a3e65"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00959.html#ga0316f640da7481e9bd03ed51b29a3e65">pstorage_update</a> (pstorage_handle_t *p_dest, uint8_t *p_src, pstorage_size_t size, pstorage_size_t offset)</td></tr>
<tr class="memdesc:ga0316f640da7481e9bd03ed51b29a3e65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routine to update persistently stored data of length 'size' contained in 'p_src' address in storage module at 'p_dest' address.  <a href="#ga0316f640da7481e9bd03ed51b29a3e65">More...</a><br/></td></tr>
<tr class="separator:ga0316f640da7481e9bd03ed51b29a3e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99402440650cc2d2ee63d8866760a25b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00959.html#ga99402440650cc2d2ee63d8866760a25b">pstorage_load</a> (uint8_t *p_dest, pstorage_handle_t *p_src, pstorage_size_t size, pstorage_size_t offset)</td></tr>
<tr class="memdesc:ga99402440650cc2d2ee63d8866760a25b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routine to load persistently stored data of length 'size' from 'p_src' address to 'p_dest' address; Equivalent to Storage Read.  <a href="#ga99402440650cc2d2ee63d8866760a25b">More...</a><br/></td></tr>
<tr class="separator:ga99402440650cc2d2ee63d8866760a25b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64d9814f864c3f771a99eb7574e87dd0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00959.html#ga64d9814f864c3f771a99eb7574e87dd0">pstorage_clear</a> (pstorage_handle_t *p_base_id, pstorage_size_t size)</td></tr>
<tr class="memdesc:ga64d9814f864c3f771a99eb7574e87dd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routine to clear data in persistent memory.  <a href="#ga64d9814f864c3f771a99eb7574e87dd0">More...</a><br/></td></tr>
<tr class="separator:ga64d9814f864c3f771a99eb7574e87dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1553a4d6d6d8ddf070d0eb4960b72d62"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00959.html#ga1553a4d6d6d8ddf070d0eb4960b72d62">pstorage_access_status_get</a> (uint32_t *p_count)</td></tr>
<tr class="memdesc:ga1553a4d6d6d8ddf070d0eb4960b72d62"><td class="mdescLeft">&#160;</td><td class="mdescRight">API to get status of number of pending operations with the module.  <a href="#ga1553a4d6d6d8ddf070d0eb4960b72d62">More...</a><br/></td></tr>
<tr class="separator:ga1553a4d6d6d8ddf070d0eb4960b72d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Functions/Interface SDK modules use to persistently store data. </p>
<p>Interface for Application &amp; SDK module to load/store information persistently. Note: that while implementation of each of the persistent storage access function depends on the system and can specific to system/solution, the signature of the interface routines should not be altered. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga1553a4d6d6d8ddf070d0eb4960b72d62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pstorage_access_status_get </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>p_count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>API to get status of number of pending operations with the module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p_count</td><td>Number of storage operations pending with the module, if 0, there are no outstanding requests.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>on success, else an error code indicating reason for failure. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_STATE</td><td>is returned is API is called without module initialization. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NULL</td><td>if NULL parameter has been passed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafdeeb475e4f2db19863226bc55d507b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pstorage_block_identifier_get </td>
          <td>(</td>
          <td class="paramtype">pstorage_handle_t *&#160;</td>
          <td class="paramname"><em>p_base_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pstorage_size_t&#160;</td>
          <td class="paramname"><em>block_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pstorage_handle_t *&#160;</td>
          <td class="paramname"><em>p_block_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get block id with reference to base block identifier provided at time of registration. </p>
<p>Function to get block id with reference to base block identifier provided at time of registration. In case more than one memory blocks were requested when registering, the identifier provided here is the base identifier for the first block and to identify subsequent block, application shall use this routine to get block identifier providing input as base identifier and block number. Therefore if 10 blocks of size 64 are requested and application wishes to store memory in 6th block, it shall use @ref pstorage_block_identifier_get with based id and provide a block number of 5. This way application is only expected to remember the base block identifier.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_base_id</td><td>Base block id received at the time of registration. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block_num</td><td>Block Number, with first block numbered zero. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_block_id</td><td>Block identifier for the block number requested in case the API succeeds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>on success, else an error code indicating reason for failure. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_STATE</td><td>is returned is API is called without module initialization. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NULL</td><td>if NULL parameter has been passed. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_PARAM</td><td>if invalid parameters are passed to the API. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga64d9814f864c3f771a99eb7574e87dd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pstorage_clear </td>
          <td>(</td>
          <td class="paramtype">pstorage_handle_t *&#160;</td>
          <td class="paramname"><em>p_base_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pstorage_size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Routine to clear data in persistent memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_base_id</td><td>Base block identifier in persistent memory that needs to cleared; Equivalent to an Erase Operation.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of data to be cleared from persistent memory expressed in bytes. This parameter is to provision for clearing of certain blocks of memory, or all memory blocks in a registered module. If the total size of the application module is used (blocks * block size) in combination with the identifier for the first block in the module, all blocks in the module will be erased.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>on success, else an error code indicating reason for failure. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_STATE</td><td>is returned is API is called without module initialization. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NULL</td><td>if NULL parameter has been passed. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_PARAM</td><td>if invalid parameters are passed to the API. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_ADDR</td><td>in case data address 'p_dst' is not aligned. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NO_MEM</td><td>in case request cannot be processed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Clear operations may take time. This API however, does not block until the clear procedure is complete. Application is notified of procedure completion using notification callback registered by the application. 'result' parameter of the callback suggests if the procedure was successful or not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga729ef8b64fc0cb6bfdabb2543a565d32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pstorage_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Module Initialization Routine. </p>
<p>Initializes module. To be called once before any other APIs of the module are used.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>on success, else an error code indicating reason for failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga99402440650cc2d2ee63d8866760a25b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pstorage_load </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>p_dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pstorage_handle_t *&#160;</td>
          <td class="paramname"><em>p_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pstorage_size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pstorage_size_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Routine to load persistently stored data of length 'size' from 'p_src' address to 'p_dest' address; Equivalent to Storage Read. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_dest</td><td>Destination address where persistently stored data is to be loaded. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_src</td><td>Source from where data is to be loaded from persistent memory. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of data to be loaded from persistent memory expressed in bytes. Should be word aligned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Offset in bytes to be applied when loading from the block. For example, if within a block of 100 bytes, application wishes to load 20 bytes from offset of 12, then this field should be set to 12. Should be word aligned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>on success, else an error code indicating reason for failure. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_STATE</td><td>is returned is API is called without module initialization. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NULL</td><td>if NULL parameter has been passed. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_PARAM</td><td>if invalid parameters are passed to the API. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_ADDR</td><td>in case data address 'p_dst' is not aligned. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NO_MEM</td><td>in case request cannot be processed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0a57b964c8945eaca2d267835ef6688c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pstorage_register </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00453.html">pstorage_module_param_t</a> *&#160;</td>
          <td class="paramname"><em>p_module_param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pstorage_handle_t *&#160;</td>
          <td class="paramname"><em>p_block_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register with persistent storage interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_module_param</td><td>Module registration param. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_block_id</td><td>Block identifier to identify persistent memory blocks in case registration succeeds. Application is expected to use the block ids for subsequent operations on requested persistent memory. Maximum registrations permitted is determined by configuration parameter PSTORAGE_MAX_APPLICATIONS. In case more than one memory blocks are requested, the identifier provided here is the base identifier for the first block and to identify subsequent block, application shall use @ref pstorage_block_identifier_get with this base identifier and block number. Therefore if 10 blocks of size 64 are requested and application wishes to store memory in 6th block, it shall use @ref pstorage_block_identifier_get with based id and provide a block number of 5. This way application is only expected to remember the base block identifier.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>To register an area with a total size (block count * block size) larger than the page size (usually 1024 bytes), the block size must be a divisor of the page size (page size % block size == 0).</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>on success, else an error code indicating reason for failure. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_STATE</td><td>is returned is API is called without module initialization. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NULL</td><td>if NULL parameter has been passed. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_PARAM</td><td>if invalid parameters are passed to the API. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NO_MEM</td><td>in case no more registrations can be supported. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga12e52da12709de8d43bfb8389b80af6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pstorage_store </td>
          <td>(</td>
          <td class="paramtype">pstorage_handle_t *&#160;</td>
          <td class="paramname"><em>p_dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>p_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pstorage_size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pstorage_size_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Routine to persistently store data of length 'size' contained in 'p_src' address in storage module at 'p_dest' address; Equivalent to Storage Write. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_dest</td><td>Destination address where data is to be stored persistently. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_src</td><td>Source address containing data to be stored. API assumes this to be resident memory and no intermediate copy of data is made by the API. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of data to be stored expressed in bytes. Should be word aligned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Offset in bytes to be applied when writing to the block. For example, if within a block of 100 bytes, application wishes to write 20 bytes at offset of 12, then this field should be set to 12. Should be word aligned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>on success, else an error code indicating reason for failure. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_STATE</td><td>is returned is API is called without module initialization. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NULL</td><td>if NULL parameter has been passed. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_PARAM</td><td>if invalid parameters are passed to the API. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_ADDR</td><td>in case data address 'p_src' is not aligned. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NO_MEM</td><td>in case request cannot be processed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>No copy of the data is made, and hence memory provided for data source to be written to flash cannot be freed or reused by the application until this procedure is complete. End of this procedure is notified to the application using the notification callback registered by the application. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0316f640da7481e9bd03ed51b29a3e65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pstorage_update </td>
          <td>(</td>
          <td class="paramtype">pstorage_handle_t *&#160;</td>
          <td class="paramname"><em>p_dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>p_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pstorage_size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pstorage_size_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Routine to update persistently stored data of length 'size' contained in 'p_src' address in storage module at 'p_dest' address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_dest</td><td>Destination address where data is to be updated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_src</td><td>Source address containing data to be stored. API assumes this to be resident memory and no intermediate copy of data is made by the API. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of data to be stored expressed in bytes. Should be word aligned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Offset in bytes to be applied when writing to the block. For example, if within a block of 100 bytes, application wishes to write 20 bytes at offset of 12, then this field should be set to 12. Should be word aligned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>on success, else an error code indicating reason for failure. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_STATE</td><td>is returned is API is called without module initialization. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NULL</td><td>if NULL parameter has been passed. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_PARAM</td><td>if invalid parameters are passed to the API. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_ADDR</td><td>in case data address 'p_src' is not aligned. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NO_MEM</td><td>in case request cannot be processed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>No copy of the data is made, and hence memory provided for data source to be written to flash cannot be freed or reused by the application until this procedure is complete. End of this procedure is notified to the application using the notification callback registered by the application. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu May 7 2015 14:36:29 for nRF51 SDK - S110 SoftDevice by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.3.1 </li>
  </ul>
</div>
</body>
</html>
