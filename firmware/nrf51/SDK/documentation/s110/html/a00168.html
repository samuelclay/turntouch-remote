<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>nRF51 SDK - S110 SoftDevice: Persistent Storage Manager</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="nordic_small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">nRF51 SDK - S110 SoftDevice
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>API&#160;Reference</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a00168.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Persistent Storage Manager </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="pstorage_intro"></a>
Introduction</h1>
<p>A typical <em>Bluetooth</em> low energy (BLE) example is when a bonded peer configuration needs to be cached to store the bond identification, GATT Server configuration, and/or GATT Server attribute handles. This is just one example of several reasons why persistent data storage is needed.</p>
<p>The Persistent Storage Manager has a generic API (<a class="el" href="a00956.html">Persistent Storage Interface</a>) used by SDK modules for common storage access. A generic API allows for SDK modules to be reused directly on other platforms. All modules using the Persistent Storage Manager are decoupled from accessing the nRF51822 flash directly. This allows for improved re-usability of SDK modules. For example, the Bond Manager can be used on processors other than nRF51822. This can be achieved by implementing a storage module according to the Persistent Storage Manager API for the targeted platform.</p>
<p>To summarize, the application interface of this module is as defined in the header and should not be altered to have zero impact on other SDK modules. However, the implementation of the interface is expected to vary based on storage solution identified for the system. Hence, pstorage.h defines the application interface, while pstorage_platform.h is use case and system specific file that can contain defines and routines needed for a specific implementation of the identified interface. The source file, pstorage.c shall implement the needed APIs. SDK examples include implementation of the interface using the SoftDevice APIs for flash access on the chip.</p>
<p>Multiple SDK modules and application itself may be require storing data, each module may have its own data size requirements. Therefore, this module allows registering with it with various block size and block count, each with a separate event handler to be notified of result of flash access.</p>
<div class="image">
<img src="pstorage.png" alt="pstorage.png"/>
<div class="caption">
Figure 1: Multiple blocks requested storage blocks.</div></div>
<h1><a class="anchor" id="pstorage_api_overview"></a>
Application Interface Overview</h1>
<p>Any SDK or application component that requires storing its data registers with the module using the <a class="el" href="a00959.html#ga0a57b964c8945eaca2d267835ef6688c">pstorage_register</a>, requesting at the time of registry number of blocks of storage it needs and how many such blocks. The interface is designed to be asynchronous and application is also expected to register a callback to know the result of a storage access operation. Identified storage access operations include load, store and clear. Once application is successfully registered, application is assigned a handle for all future operations needed for accessing these storage blocks. pstorage_handle_t (in the platform-specific header file) abstracts this handle.</p>
<dl class="section warning"><dt>Warning</dt><dd>Before accessing any of the APIs of the module, the module shall be initialized using the <a class="el" href="a00168.html#pstorage_init">Initialization</a>. This initialization should be performed once.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For implementation of interface included in the example, SoftDevice should be enabled and scheduler (if used) should be initialized prior to initializing this module.</dd></dl>
<p>Application does not have to remember a handle or an identifier for each of the blocks, instead it just needs to remember one identifier for all the blocks. When, reference to a specific block for flash access is required, <a class="el" href="a00959.html#gafdeeb475e4f2db19863226bc55d507b5">pstorage_block_identifier_get</a> API shall be used to get a block specific handle. Base handle and block number counting from 0 are provided as input to the API.</p>
<p>As mentioned earlier, an asynchronous interface is defined for storage access as storing data or clearing data can take time. However no copy of data to be stored is made by the implementation included in the SDK. Therefore, data source provided for store operation using the <a class="el" href="a00168.html#pstorage_store">Store Data</a> API, expects resident memory, meaning that the memory pointed to by data source for this API should not be reused or freed unless client is notified of completion of store operation using the asynchronous notification callback registered with the module by the client.</p>
<h2><a class="anchor" id="pstorage_init"></a>
Initialization</h2>
<p>The storage module must be initialized before using any other API of the module.</p>
<div class="fragment"><div class="line">uint32_t retval;</div>
<div class="line"></div>
<div class="line">retval = <a class="code" href="a00959.html#ga729ef8b64fc0cb6bfdabb2543a565d32" title="Module Initialization Routine.">pstorage_init</a>();</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">if</span>(retval == <a class="code" href="a01051.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Module initialization successful.</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">{</div>
<div class="line">   <span class="comment">// Initialization failed, take corrective action.</span></div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="pstorage_registration"></a>
Registration</h2>
<p>A module that requires storage must register with the storage module in order to allocate storage blocks for data. The application must register the asynchronous event notification handler, number of blocks, and block size which should be in range of PSTORAGE_MIN_BLOCK_SIZE and PSTORAGE_MAX_BLOCK_SIZE. A reference handle is given to the application once registration is successful and is remembered by the application to reference the storage blocks.</p>
<dl class="section note"><dt>Note</dt><dd>To register an area with a total size (block count * block size) larger than the page size (PSTORAGE_FLASH_PAGE_SIZE, usually 1024 bytes), the block size must be a divisor of the page size (page size % block size == 0), so that no block is split between pages.</dd></dl>
<div class="fragment"><div class="line">pstorage_handle_t       handle;</div>
<div class="line"><a class="code" href="a00453.html">pstorage_module_param_t</a> param;</div>
<div class="line">uint32_t                retval;</div>
<div class="line">      </div>
<div class="line">param.<a class="code" href="a00453.html#a95b58714824957d4c930a5da78d7109a">block_size</a>  = 100;</div>
<div class="line">param.block_count = 10;</div>
<div class="line">param.<a class="code" href="a00453.html#a3495db72b9ff587f0c9ea0ab38d5e9f8">cb</a>          = example_cb_handler;</div>
<div class="line">    </div>
<div class="line">retval = <a class="code" href="a00959.html#ga0a57b964c8945eaca2d267835ef6688c" title="Register with persistent storage interface.">pstorage_register</a>(&amp;param, &amp;handle);</div>
<div class="line"><span class="keywordflow">if</span> (retval == <a class="code" href="a01051.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Registration successful.</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Failed to register, take corrective action.</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The application is provided here with a single handle for all blocks and dedicated handle for each block. This saves the application from having to remember too many handles. The handle provided to the application is referred to as the base handle for the blocks allocated. The application shall use <a class="el" href="a00959.html#gafdeeb475e4f2db19863226bc55d507b5">pstorage_block_identifier_get</a> to acquire a specific block reference.</dd></dl>
<h2><a class="anchor" id="pstorage_get_block_id"></a>
Get Block Identifier</h2>
<p>This API provides a specific block reference to the application in allocated blocks. Allocated blocks are identified by the base block identifier provided at the time of registration. Block offset are indexed starting from zero to (number of blocks allocated - 1).</p>
<p>This API shall be called before a load or store operation to a specific block.</p>
<div class="fragment"><div class="line">pstorage_handle_t base_handle;</div>
<div class="line">pstorage_handle_t block_handle;</div>
<div class="line">uint32_t          retval;</div>
<div class="line"></div>
<div class="line">.</div>
<div class="line">.</div>
<div class="line">.</div>
<div class="line"><span class="comment">// Registration successfully completed, base_handle is identifier for allocated blocks.</span></div>
<div class="line">.</div>
<div class="line">.</div>
<div class="line">.</div>
<div class="line"></div>
<div class="line"><span class="comment">// Request to get identifier for 3rd block. </span></div>
<div class="line">retval = <a class="code" href="a00959.html#gafdeeb475e4f2db19863226bc55d507b5" title="Function to get block id with reference to base block identifier provided at time of registration...">pstorage_block_identifier_get</a>(&amp;base_handle, 2, &amp;block_handle);</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">if</span> (retval == <a class="code" href="a01051.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Get Block Identifier successful.</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Failed to get block id, take corrective action.</span></div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="pstorage_load"></a>
Load Data</h2>
<p>This API is used to read data from a storage block. It is permitted to read a part of the block using the offset field. The application should ensure the destination has enough memory to copy data from the storage block to the destination pointer provided in the API.</p>
<dl class="section note"><dt>Note</dt><dd>Block size and offset in load and store should be a multiple of word size (4 bytes). <a class="el" href="a00168.html#pstorage_get_block_id">Get Block Identifier</a> API shall be used before this API to get block specific identifier.</dd></dl>
<div class="fragment"><div class="line">pstorage_handle_t block_handle;</div>
<div class="line">uint8_t           dest_data[4];</div>
<div class="line">uint32_t          retval;    </div>
<div class="line"></div>
<div class="line"><span class="comment">// Request to read 4 bytes from block at an offset of 12 bytes.</span></div>
<div class="line">retval = <a class="code" href="a00959.html#ga99402440650cc2d2ee63d8866760a25b" title="Routine to load persistently stored data of length &#39;size&#39; from &#39;p_src&#39; address to &#39;p_dest&#39; address; E...">pstorage_load</a>(dest_data, &amp;block_handle, 4, 12);</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">if</span> (retval == <a class="code" href="a01051.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Load successful. Consume data.</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Failed to load, take corrective action.</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The SDK implementation requires the offset and size to be a multiple of word size (4 bytes) and will not generate a success or failure event. API return value determines determines the result of this operation.</dd></dl>
<h2><a class="anchor" id="pstorage_store"></a>
Store Data</h2>
<p>This API is used to write data to a storage block. It is permitted to write only a part of the block using the offset field. Application cannot free or reuse the memory that is the source of data until this operation is complete. The event notified using registered callback will indicate when this operation is complete. Event result indicates whether the operation was successful or not.</p>
<dl class="section note"><dt>Note</dt><dd>Block size and offset in load and store should be a multiple of word size (4 bytes). <a class="el" href="a00168.html#pstorage_get_block_id">Get Block Identifier</a> API shall be used before this API to get a specific block identifier.</dd></dl>
<div class="fragment"><div class="line">pstorage_handle_t block_handle;</div>
<div class="line">uint8_t           source_data[4];</div>
<div class="line">uint32_t          retval;    </div>
<div class="line"></div>
<div class="line"><span class="comment">// Request to write 8 bytes to block at an offset of 20 bytes.</span></div>
<div class="line">retval = <a class="code" href="a00959.html#ga12e52da12709de8d43bfb8389b80af6d" title="Routine to persistently store data of length &#39;size&#39; contained in &#39;p_src&#39; address in storage module at...">pstorage_store</a>(&amp;block_handle, source_data, 8, 20);</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">if</span> (retval == <a class="code" href="a01051.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Store successfully requested. Wait for operation result.</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Failed to request store, take corrective action.</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">.</div>
<div class="line">.</div>
<div class="line">.</div>
<div class="line"></div>
<div class="line"><span class="comment">// Event Notification Handler.</span></div>
<div class="line">static <span class="keywordtype">void</span> example_cb_handler(pstorage_handle_t  * handle,</div>
<div class="line">                               uint8_t              op_code,</div>
<div class="line">                               uint32_t             result,</div>
<div class="line">                               uint8_t            * p_data,</div>
<div class="line">                               uint32_t             data_len)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">switch</span>(op_code)</div>
<div class="line">    {</div>
<div class="line">       .</div>
<div class="line">       .</div>
<div class="line">       .</div>
<div class="line">       <span class="keywordflow">case</span> <a class="code" href="a00957.html#ga4e04e36e3adf60869073dce4af46b7d5">PSTORAGE_LOAD_OP_CODE</a>:</div>
<div class="line">           <span class="keywordflow">if</span> (result == <a class="code" href="a01051.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a>)</div>
<div class="line">           {</div>
<div class="line">               <span class="comment">// Store operation successful.</span></div>
<div class="line">           }</div>
<div class="line">           <span class="keywordflow">else</span></div>
<div class="line">           {</div>
<div class="line">               <span class="comment">// Store operation failed.</span></div>
<div class="line">           }</div>
<div class="line">           <span class="comment">// Source memory can now be reused or freed.</span></div>
<div class="line">           <span class="keywordflow">break</span>;</div>
<div class="line">       .</div>
<div class="line">       .</div>
<div class="line">       .</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Flash memory is unreliable when writing to a block already containing data, a clear operation is needed. The SDK implementation does not clear the blocks before writing to them. The application, not the storage module, must perform a clear operation before new data is written to the block.</dd></dl>
<h2><a class="anchor" id="pstorage_update"></a>
Update Data</h2>
<p>This API is used to update data in storage blocks. Application cannot free or reuse the memory that is the source of data until this operation is complete. The event notified using registered callback will indicate when this operation is complete. Event result indicates whether the operation was successful or not.</p>
<div class="fragment"><div class="line">pstorage_handle_t base_handle;</div>
<div class="line">uint8_t           source_data[16];</div>
<div class="line">uint32_t          retval;    </div>
<div class="line"></div>
<div class="line"><span class="comment">// Request update of one blocks. Block size is 16 bytes.</span></div>
<div class="line">retval = <a class="code" href="a00959.html#ga0316f640da7481e9bd03ed51b29a3e65" title="Routine to update persistently stored data of length &#39;size&#39; contained in &#39;p_src&#39; address in storage m...">pstorage_update</a>(&amp;base_handle, source_data, 16, 0);</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">if</span> (retval == <a class="code" href="a01051.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Update successfully requested. Wait for operation result.</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Failed to request update, take corrective action.</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">.</div>
<div class="line">.</div>
<div class="line">.</div>
<div class="line"></div>
<div class="line"><span class="comment">// Event Notification Handler.</span></div>
<div class="line">static <span class="keywordtype">void</span> example_cb_handler(pstorage_handle_t  * handle,</div>
<div class="line">                               uint8_t              op_code,</div>
<div class="line">                               uint32_t             result,</div>
<div class="line">                               uint8_t            * p_data,</div>
<div class="line">                               uint32_t             data_len)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">switch</span>(op_code)</div>
<div class="line">    {</div>
<div class="line">       .</div>
<div class="line">       .</div>
<div class="line">       .</div>
<div class="line">       <span class="keywordflow">case</span> <a class="code" href="a00957.html#gae66936fc791b79a9f85a7058ea83423a">PSTORAGE_UPDATE_OP_CODE</a>:</div>
<div class="line">           <span class="keywordflow">if</span> (result == <a class="code" href="a01051.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a>)</div>
<div class="line">           {</div>
<div class="line">               <span class="comment">// Update operation successful.</span></div>
<div class="line">           }</div>
<div class="line">           <span class="keywordflow">else</span></div>
<div class="line">           {</div>
<div class="line">               <span class="comment">// Update operation failed.</span></div>
<div class="line">           }</div>
<div class="line">           <span class="keywordflow">break</span>;</div>
<div class="line">       .</div>
<div class="line">       .</div>
<div class="line">       .</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="pstorage_clear"></a>
Clear Data</h2>
<p>This API is used to clear data in storage blocks. The event notified using registered callback will indicate when this operation is complete. Event result indicates whether the operation was successful or not.</p>
<p>The size requested to be erased has to be within or equal the size of a block. If a size less than block size is given, the API will clear the requested number of bytes beginning at the first memory location in the block. It is not possible to request a size which spans to the next block in the module.</p>
<div class="fragment"><div class="line">pstorage_handle_t base_handle;</div>
<div class="line">uint32_t          retval;    </div>
<div class="line"></div>
<div class="line"><span class="comment">// Request clearing of all blocks in the module. 32 blocks each with 16 bytes in size.</span></div>
<div class="line">retval = <a class="code" href="a00959.html#ga64d9814f864c3f771a99eb7574e87dd0" title="Routine to clear data in persistent memory.">pstorage_clear</a>(&amp;base_handle, 32 * 16);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Request clearing of one block where block size is 16 bytes.</span></div>
<div class="line">retval = <a class="code" href="a00959.html#ga64d9814f864c3f771a99eb7574e87dd0" title="Routine to clear data in persistent memory.">pstorage_clear</a>(&amp;base_handle, 16);</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">if</span> (retval == <a class="code" href="a01051.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Clear successfully requested. Wait for operation result.</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Failed to request clear, take corrective action.</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">.</div>
<div class="line">.</div>
<div class="line">.</div>
<div class="line"></div>
<div class="line"><span class="comment">// Event Notification Handler.</span></div>
<div class="line">static <span class="keywordtype">void</span> example_cb_handler(pstorage_handle_t  * handle,</div>
<div class="line">                               uint8_t              op_code,</div>
<div class="line">                               uint32_t             result,</div>
<div class="line">                               uint8_t            * p_data,</div>
<div class="line">                               uint32_t             data_len)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">switch</span>(op_code)</div>
<div class="line">    {</div>
<div class="line">       .</div>
<div class="line">       .</div>
<div class="line">       .</div>
<div class="line">       <span class="keywordflow">case</span> <a class="code" href="a00957.html#gaf2ce8b4e460358a23ae82516167df79c">PSTORAGE_CLEAR_OP_CODE</a>:</div>
<div class="line">           <span class="keywordflow">if</span> (result == <a class="code" href="a01051.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a>)</div>
<div class="line">           {</div>
<div class="line">               <span class="comment">// Clear operation successful.</span></div>
<div class="line">           }</div>
<div class="line">           <span class="keywordflow">else</span></div>
<div class="line">           {</div>
<div class="line">               <span class="comment">// Clear operation failed.</span></div>
<div class="line">           }</div>
<div class="line">           <span class="keywordflow">break</span>;</div>
<div class="line">       .</div>
<div class="line">       .</div>
<div class="line">       .</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="pstorage_status_get"></a>
Get Status</h2>
<p>The Persistent Storage Manager allows application to get a count of how many storage access operations are pending with it using the <a class="el" href="a00959.html#ga1553a4d6d6d8ddf070d0eb4960b72d62">pstorage_access_status_get</a> API. This is particularly useful when you want to enter power off mode or want to enter a radio intense operation, but before doing so, want to ensure that the storage operations have been completed.</p>
<div class="fragment"><div class="line">uint32_t    retval;</div>
<div class="line">uint32_t    count;   </div>
<div class="line"></div>
<div class="line"><span class="comment">// Request clearing of blocks</span></div>
<div class="line">retval = <a class="code" href="a00959.html#ga1553a4d6d6d8ddf070d0eb4960b72d62" title="API to get status of number of pending operations with the module.">pstorage_access_status_get</a>(&amp;count);</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">if</span> (count == 0)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// No pending operations, safe to power off or enter radio intense operations.</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Storage access pending, wait!</span></div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="pstorage_raw_mode"></a>
Raw Mode</h1>
<p>Certain use cases require complete control of the entire flash region and do not have typical storage requirements. The storage module then provisions for one application to be registered with it in the 'raw' mode. In raw mode, the application is responsible for conceptualizing the flash region as blocks and their management. Dedicated APIs, register, store, and clear, are provided to distinguish raw mode from the normal mode. Raw mode APIs have a similar signature to the normal mode.</p>
<p>As this is not a typical use case, and is included for a targeted few applications like the DFU, the raw mode by default is disabled and is included only if PSTORAGE_RAW_MODE_ENABLE is defined in the pstorage_platform.h header.</p>
<h1><a class="anchor" id="pstorage_implement_specifics"></a>
Specifics and limitations of the SDK implementation</h1>
<p>Additional requirements and a few limitations exist when implementing the example included. Some have already been mentioned but the following is a summarized list with more detailed information.</p>
<p>General:</p>
<ul>
<li>The SoftDevice and scheduler must be initialized first before initializing the Persistent Storage Module. Modules that use this storage module shall then be initialized after the storage module.</li>
<li>Block size and offset in load, store and update shall be a multiple of word size (4 bytes).</li>
<li>Module APIs are not thread-safe or re-entrant.</li>
<li>In case blocks span across multiple flash pages update and clear of blocks might not work as expected.</li>
<li>The application is expected to ensure that when a System OFF is issued, flash access is not ongoing or queued with the module.</li>
<li>In addition to the error codes listed in the header file for pstorage the SoC flash API error codes can also be returned if API call does not succeed.</li>
<li>Loading, storing, updating and clearing of each block is supported. A single operation can not be requested for multiple blocks. However, clear is permitted on requested blocks. This is the only exception.</li>
<li>Power off is not handled by the module. Hence power off when a flash operation is on-going or pending results in lose of data.</li>
<li>Registering for system events and passing them on to pstorage module using the pstorage_sys_event_handler is mandatory for the module to function as expected. Code snippet below demonstrates what application needs to do for this. <div class="fragment"><div class="line"><span class="comment">/**@brief Function for dispatching a system event to interested modules.</span></div>
<div class="line"><span class="comment">  </span></div>
<div class="line"><span class="comment">   @details This function is called from the System event interrupt handler after a system</span></div>
<div class="line"><span class="comment">            event has been received.</span></div>
<div class="line"><span class="comment">  </span></div>
<div class="line"><span class="comment">   @param[in]   sys_evt   System stack event.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> sys_evt_dispatch(uint32_t sys_evt)</div>
<div class="line">{</div>
<div class="line">    pstorage_sys_event_handler(sys_evt);</div>
<div class="line">}</div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">/**@brief BLE stack initialization.</span></div>
<div class="line"><span class="comment">  </span></div>
<div class="line"><span class="comment">   @details Initializes the SoftDevice and the stack event interrupt.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> ble_ant_stack_init(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Initialize SoftDevice</span></div>
<div class="line">    <a class="code" href="a01189.html#ga83d8751e9fa1193e3be7524a696aa36c" title="Macro for initializing the stack event handler.">SOFTDEVICE_HANDLER_INIT</a>(<a class="code" href="a01311.html#ggaef6aabaa8887cb4d7265d7e21b3ec242a1c5e9917211a50eac336a3fd2e467756">NRF_CLOCK_LFCLKSRC_XTAL_20_PPM</a>, <span class="keyword">false</span>);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Subscribe for BLE events.</span></div>
<div class="line">    uint32_t err_code = <a class="code" href="a01188.html#gae54951e939156d5f05fa4d27fed1dc65" title="Function for registering for BLE events.">softdevice_ble_evt_handler_set</a>(ble_evt_dispatch);</div>
<div class="line">    <a class="code" href="a00989.html#ga82d00a810dcea7dcc6af469461fb254c" title="Macro for calling error handler function if supplied error code any other than NRF_SUCCESS.">APP_ERROR_CHECK</a>(err_code);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Register with the SoftDevice handler module for System events.</span></div>
<div class="line">    err_code = <a class="code" href="a01189.html#ga200d4e1f1c70a46e6de6343f0a7d84b1" title="Function for registering for System (SOC) events.">softdevice_sys_evt_handler_set</a>(sys_evt_dispatch);</div>
<div class="line">    <a class="code" href="a00989.html#ga82d00a810dcea7dcc6af469461fb254c" title="Macro for calling error handler function if supplied error code any other than NRF_SUCCESS.">APP_ERROR_CHECK</a>(err_code);</div>
<div class="line">}</div>
</div><!-- fragment --></li>
</ul>
<p>Registration:</p>
<ul>
<li>Registration of a new module shall use a block size which is a multiple of word size (4 bytes).</li>
</ul>
<p>Store:</p>
<ul>
<li>Writing data to blocks that already have data stored is unreliable. The application must clear the blocks before writing fresh data to it.</li>
<li>No intermediate copy of source data to be stored in flash is made. Application cannot free or reuse the memory that is the source of data until this operation is complete. Completion of this operation is notified through the event notification callback.</li>
</ul>
<p>Update:</p>
<ul>
<li>When using the update routine the Persistent Storage Manager will use a swap area to conserve the blocks not affected. The data page backed up in the swap area, the data page is erased, the non affected blocks are copied back, then the updated block is stored. It is not possible to update multiple blocks in one API call. Module detects if backing up the page is needed or not and optimizes accordingly.</li>
<li>No intermediate copy of source data to be stored in flash is made. Application cannot free or reuse the memory that is the source of data until this operation is complete. Completion of this operation is notified through the event notification callback.</li>
<li>Update operation is a time intensive operation, hence developer descretion is required on usage of this API. Application should be tolerant to this.</li>
</ul>
<p>Clear:</p>
<ul>
<li>Clear operation results in clearing all storage blocks allocated to the application. Clearing a single storage block or certain blocks is not implemented. The size parameter of pstorage_clear is currently unused, any value provided will not have any impact on the behaviour of this API.</li>
<li>The Persistent Storage Module interface allows clearing individual blocks, but the SDK implementation does not. When a clear operation is requested, the current implementation clears all blocks allocated for the module.</li>
<li>When using the clear operation the Persistent Storage Manager will use a swap area to conserve the blocks not affected. The data page backed up in the swap area, the data page is erased, the non affected blocks are copied back.</li>
<li>The size shall be multiple of block size expressed in number of bytes. The implementation does not allow clearing a region within a block.</li>
<li>Update operation is a time intensive operation, hence developer descretion is required on usage of this API. Application should be tolerant to this. </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="a00003.html">Libraries</a></li>
    <li class="footer">Generated on Thu May 7 2015 14:36:29 for nRF51 SDK - S110 SoftDevice by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.3.1 </li>
  </ul>
</div>
</body>
</html>
