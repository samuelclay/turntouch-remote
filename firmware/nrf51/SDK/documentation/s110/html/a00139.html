<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>nRF51 SDK - S110 SoftDevice: Enhanced ShockBurst User Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="nordic_small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">nRF51 SDK - S110 SoftDevice
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>API&#160;Reference</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a00139.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Enhanced ShockBurst User Guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#esb_intro">Introduction</a></li>
<li class="level1"><a href="#features">Features</a></li>
<li class="level1"><a href="#esb_config">Resources</a></li>
<li class="level1"><a href="#esb_backwards">Backwards Compatibility</a></li>
<li class="level1"><a href="#esb_transaction">Packet transaction</a></li>
<li class="level1"><a href="#esb_getting_started">Setting up an ESB application</a></li>
<li class="level1"><a href="#freq_select">Frequency selection</a><ul><li class="level2"><a href="#addressing">Pipes and addressing</a></li>
</ul>
</li>
<li class="level1"><a href="#packet_id">Packet identification</a></li>
<li class="level1"><a href="#FIFOs">FIFOs</a><ul><li class="level2"><a href="#ptx_fifo">PTX FIFO handling</a></li>
<li class="level2"><a href="#prx_FIFO">PRX FIFO handling</a></li>
</ul>
</li>
<li class="level1"><a href="#callback_queuing">Callback queuing</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="esb_intro"></a>
Introduction</h1>
<p>This user guide describes what Enhanced ShockBurst (ESB) is and how to use it with an nRF51 device.</p>
<p>Enhanced ShockBurst (ESB) is a basic protocol supporting two-way data packet communication including packet buffering, packet acknowledgement, and automatic retransmission of lost packets.</p>
<p>The ESB protocol was embedded in hardware in the legacy nRF24L Series. The nRF51 ESB software library enables an nRF51 device to communicate with an nRF24L device using the ESB protocol.</p>
<p>ESB features automatic packet transaction handling for easy implementation of a reliable bi-directional data link. A transaction is a packet exchange between two transceivers, with one transceiver acting as the Primary Receiver (PRX) and the other transceiver acting as the Primary Transmitter (PTX).</p>
<p>ESB is provided for customers who want to communicate with nRF24Lxx products. We recommend using Gazell for new nRF51 proprietary radio designs as Gazell achieves superior wireless coexistence performance without sacrificing power consumption, code space, or ease of use.</p>
<div class="image">
<img src="esb_fig1_star_network.png" alt="esb_fig1_star_network.png"/>
<div class="caption">
Enhanced ShockBurst network</div></div>
<h1><a class="anchor" id="features"></a>
Features</h1>
<ul>
<li>Supports a star network topology with typically one Primary Receiver (PRX) and up to 8 Primary Transmitters (PTX).</li>
<li>1 to 32 bytes dynamic payload length.</li>
<li>Bi-directional data transfer between each PTX and the PRX.</li>
<li>Packet acknowledgement and automatic packet retransmission functionality.</li>
<li>Individual TX and RX FIFOs for every pipe.</li>
<li>Backward compatible with legacy nRF24Lxx Enhanced ShockBurst.</li>
</ul>
<h1><a class="anchor" id="esb_config"></a>
Resources</h1>
<p>ESB makes use of a fixed set of resources and requires exclusive access to them for ESB to ensure correct operation. There are two options for what set of resources to be used:</p>
<ol type="1">
<li>esb_arm.lib</li>
</ol>
<ul>
<li>Radio (NRF_RADIO)</li>
<li>Timer: NRF_TIMER2)</li>
<li>PPI channels 0, 1, and 2</li>
<li>Software interrupt 0</li>
</ul>
<ol type="1">
<li>esb_sd_resources_arm.lib (reusing the same resources used by the S1xx Bluetooth Smart softdevice library from Nordic):</li>
</ol>
<ul>
<li>Radio (NRF_RADIO)</li>
<li>Timer: NRF_TIMER0)</li>
<li>PPI Channels 8, 9, and 10</li>
<li>Software interrupt 1</li>
</ul>
<p><b>Note:</b> There is no MPU enforcement of this exclusive access, so manipulating these resources will give undefined behavior.</p>
<p>The radio and timer interrupt handlers run at priority level 0 (highest level), and the ESB callback functions run at priority level 1. Other interrupts used by the application must use priority level 2 or higher to ensure correct operation.</p>
<h1><a class="anchor" id="esb_backwards"></a>
Backwards Compatibility</h1>
<p>ESB for nRF51 supports the following minimum timeslot periods:</p>
<ul>
<li>600 us timeslot period, nRF51 PTX to nRF51 PRX.</li>
<li>504 us timeslot period, nRF51 PTX to nRF24Lxx PRX.</li>
</ul>
<p>When using 504 us timeslot period, the following restrictions apply:</p>
<ul>
<li>Max payload size is 17 bytes</li>
<li>Max ack payload size is 10 bytes</li>
</ul>
<p>The nRF24Lxx ESB examples found in the legacy nRFgo SDK do not work out of the box with the nRF51 ESB examples. The retransmit delay and channel tables require the following adjustment:</p>
<ul>
<li>The legacy examples use RF channel 2 (not 10 as the nRF51 examples).</li>
<li>The legacy examples do not use "payload in ACK" or dynamic payload length.</li>
</ul>
<p>The legacy examples need to add the following in order to work with the nRF51 examples. In addition, the legacy PTX example must add code for handling the payloads received in ACK.</p>
<div class="fragment"><div class="line">hal_nrf_setup_dynamic_payload(0xFF);</div>
<div class="line">hal_nrf_enable_dynamic_payload(<span class="keyword">true</span>);</div>
<div class="line">hal_nrf_enable_ack_payload(<span class="keyword">true</span>);</div>
<div class="line">hal_nrf_set_rf_channel(10);</div>
</div><!-- fragment --><h1><a class="anchor" id="esb_transaction"></a>
Packet transaction</h1>
<p>An Enhanced ShockBurst packet transaction is initiated by a packet transmission from the PTX and successfully completed when the PTX has received an acknowledgment packet (ACK packet) from the PRX.</p>
<p>To enable a bi-directional data link the PRX is allowed to attach a data payload to the ACK packet. This can be done by uploading packet(s) to the TX FIFO(s) on the PRX.</p>
<div class="image">
<img src="esb_fig2_ptx_trans_ok.png" alt="esb_fig2_ptx_trans_ok.png"/>
<div class="caption">
PTX to PRX packet transaction</div></div>
<p>If the PTX does not receive the ACK after the initial transmitted packet, it will attempt to retransmit the packet until the ACK is finally being received. The maximum number of allowed retransmission attempts are specified by the <a class="el" href="a01190.html#ga8cdcef8f56272380546af260bcea0ad8" title="Set the maximum number of TX attempts that can be used for a single packet.">nrf_esb_set_max_number_of_tx_attempts()</a> function, and the delay in between each transmission attempt is specified using the <a class="el" href="a01190.html#gaf745d55ede0ad93b7e24af33e3ef9df2" title="Set the retransmission delay.">nrf_esb_set_retransmit_delay()</a> function.</p>
<p>The retransmission delay is defined as the duration between the start of each transmission attempt. Note that this differs from the legacy nRF24L Series hardware implementation, where this delay was defined as the duration from the end of a packet transmission until the start of the retransmission.</p>
<p>If the ACK packet sent from the PRX to the PTX is lost, but both the initial packet and the subsequent retransmission attempts are being successfully received by the PRX, the repeated packets will be discarded by the PRX. This prevents the PRX application from receiving duplicate packets.</p>
<p><b>Note:</b> Repeated packets will always be ACKed by the PRX even though they are being discarded.</p>
<div class="image">
<img src="esb_fig3_prx_ptx_trans_fail.png" alt="esb_fig3_prx_ptx_trans_fail.png"/>
<div class="caption">
Failed package transaction.</div></div>
<p>A PTX can select that individual packets transmitted to the PRX will not require an ACK to be sent in return from the PRX. This decision is taken by the application when uploading a packet to the TX FIFO using the <b>packet_type</b> parameter of the <a class="el" href="a01190.html#ga659a456d3f20b95961dcbe07769a17e6" title="Add a packet to the tail of the TX FIFO.">nrf_esb_add_packet_to_tx_fifo()</a> function.</p>
<p>When the PRX receives a packet not requiring an ACK it will not send an ACK packet to the PTX, and as a result the PTX will continue retransmitting the packet until the maximum number of allowed retransmission attempts is reached.</p>
<h1><a class="anchor" id="esb_getting_started"></a>
Setting up an ESB application</h1>
<p>Perform the following steps to set up and send and receive packets:</p>
<ol type="1">
<li>Initialize ESB using <a class="el" href="a01190.html#ga155377fe2e8a0b40352c21a5ec7979ec" title="Initialize ESB.">nrf_esb_init()</a>.</li>
<li>Reconfigure the ESB default parameters if needed.</li>
<li>Enable ESB using <a class="el" href="a01190.html#gaa7f7be8b058378a3b31d38ce88e0600f" title="Enable ESB.">nrf_esb_enable()</a>.</li>
<li>If the node is a PTX, start sending:<ul>
<li>Add payloads to the transmit (TX) FIFO using <a class="el" href="a01190.html#ga659a456d3f20b95961dcbe07769a17e6" title="Add a packet to the tail of the TX FIFO.">nrf_esb_add_packet_to_tx_fifo()</a>.</li>
<li>Handle the resulting callback that is <a class="el" href="a01190.html#ga416a6ef0fc94e7df9054e71c8784095a" title="TX success callback.">nrf_esb_tx_success()</a> if an ACK was successfully received, an additional <a class="el" href="a01190.html#gab3042dde4c3151c1517f4998378f52ce" title="RX data ready callback.">nrf_esb_rx_data_ready()</a> if the ACK contained a payload or <a class="el" href="a01190.html#ga03993c4e0419bbcac77aa0965ecce6ad" title="TX failed callback (PTX mode only).">nrf_esb_tx_failed()</a> if no ACK packet was received on any of the retransmission attempts. Failed packets (not receiving an ACK) are automatically removed from the TX FIFO.</li>
</ul>
</li>
<li>If the node is a PRX, start listening:<ul>
<li>Handle the received data packets when the <a class="el" href="a01190.html#gab3042dde4c3151c1517f4998378f52ce" title="RX data ready callback.">nrf_esb_rx_data_ready()</a> callback is called. The received packets are fetched from the RX FIFO using the <a class="el" href="a01190.html#gaef1dcdb47f1c29b01badecdeb6fb3459" title="Fetch a packet from the head of the RX FIFO.">nrf_esb_fetch_packet_from_rx_fifo()</a> function.</li>
<li>Payloads to can be attached to ACK packets by adding these to the TX FIFO using <a class="el" href="a01190.html#ga659a456d3f20b95961dcbe07769a17e6" title="Add a packet to the tail of the TX FIFO.">nrf_esb_add_packet_to_tx_fifo()</a>. If an ACK payload is assumed successfully received by the PTX, that is when a new packet sent from the PTX is received by the PRX, the <a class="el" href="a01190.html#ga416a6ef0fc94e7df9054e71c8784095a" title="TX success callback.">nrf_esb_tx_success()</a> callback will be called and the sent packet is automatically removed from the TX FIFO.</li>
</ul>
</li>
</ol>
<p>ESB can also be disabled at any time using the <a class="el" href="a01190.html#ga1888b9ea163638d761af804e89de4122" title="Disable ESB.">nrf_esb_disable()</a> function. When this is called ESB will complete any ongoing transaction before being disabled. When any ongoing transaction is completed and ESB has been disabled, the <a class="el" href="a01190.html#ga5e82709bd23aa952a883db3af5b987e0" title="Disabled callback.">nrf_esb_disabled()</a> callback will be called.</p>
<h1><a class="anchor" id="freq_select"></a>
Frequency selection</h1>
<p>ESB can send or receive packets using any of the channels that the nRF51 chip can use as selected by using the function <a class="el" href="a01190.html#gaca97648d85e0dcb1dde56545efb36df8" title="Set the Radio Frequency (RF) channel.">nrf_esb_set_channel()</a>.</p>
<p>PTX and a PRX must be configured using the same frequency to exchange packets.</p>
<h1><a class="anchor" id="addressing"></a>
Pipes and addressing</h1>
<p>Each logical address on the nodes is termed a pipe. Each pipe maps to one on-air address used when transmitting or receiving packets.</p>
<p>The on-air addresses are composed of a 2-4 byte long "base address" in addition to a 1 byte prefix address. Note that the nRF51 radio uses an alternating sequence of 0s and 1s as the preamble of the packet. Therefore, for packets to be received correctly, the most significant byte of the base address should not be an alternating sequence of 0s and 1s, that is, it should not be 0x55 or 0xAA.</p>
<p>Pipe 0 has its own unique base address, which is base address 0, while pipes 1-7 use the same base address, which is base address 1.</p>
<p>Each of the 8 pipes have a unique byte-long prefix address.</p>
<p>On-air, the most significant bit of each address byte will be transmitted first. The most significant byte of the 4 byte long base address is the first transmitted address byte, while the prefix byte is transmitted last.</p>
<p><b>Note:</b> The byte ordering in ESB and the nRF51 radio peripheral are not the same, this is because the address bytes are rearranged in ESB to match the nRF24L radios.</p>
<h1><a class="anchor" id="packet_id"></a>
Packet identification</h1>
<p>Any packet transmitted from a PTX to a PRX is uniquely identified by a two-bit packet ID field (PID) in the packet header together with the packet's Cyclic Redundancy Check (CRC) field. This packet ID is used to distinguish a new packet from the previous packet if it has the same payload.</p>
<p>At the PRX, retransmitted packets will be discarded and not added to an RX FIFO. The <a class="el" href="a01190.html#gab3042dde4c3151c1517f4998378f52ce" title="RX data ready callback.">nrf_esb_rx_data_ready()</a> will not be called.</p>
<p>The CRC is used in addition to the PID to identify a unique packet. This reduces the likelihood of a packet being falsely identified as a retransmission attempt and discarded by the PRX when several consecutive failed packet transmission attempts occur. This feature is helpful as the PID is only two bits.</p>
<h1><a class="anchor" id="FIFOs"></a>
FIFOs</h1>
<p>All eight pipes on both the PTX and the PRX have two multi-level FIFOs that can hold packets, that is, each pipe's TX FIFO and RX FIFO. For example, the total number of packets in the FIFOs is 6, while every individual TX or RX FIFO (8 pipes x 2 = 16 in total) can store 3 packets.</p>
<h2><a class="anchor" id="ptx_fifo"></a>
PTX FIFO handling</h2>
<p>When ESB is enabled in PTX mode, any packets uploaded to a TX FIFO will be transmitted at the next opportunity. For one TX FIFO the packets will be transmitted in the same order as they were written to the FIFO. But several TX FIFOs will be serviced in a round robin fashion, meaning that only one packet is transmitted from a FIFO before a packet from the next FIFO is transmitted.</p>
<p>When an ACK is successfully received from a PRX, it implies that the payload was successfully received and added to the PRX's RX FIFO, the successfully transmitted packet will be removed from the TX FIFO so that the next packet in the FIFO can be transmitted.</p>
<p>If an ACK received by a PTX contains a payload, this payload will be added to the pipe's RX FIFO.</p>
<p>If the RX FIFO for a specific pipe on a PTX is full and can not accommodate any new packets, no new packets will be sent from the PTX on this pipe. In this case, we will never end up in the situation where a payload received in an ACK will have to be discarded due to the pipe's RX FIFO being full.</p>
<h2><a class="anchor" id="prx_FIFO"></a>
PRX FIFO handling</h2>
<p>When ESB is enabled in PRX mode, all enabled pipes (addresses) are simultaneously monitored for incoming packets.</p>
<p>If a new packet not previously added to the pipe's RX FIFO is received, and the pipe's RX FIFO has available space for the packet, the packet will be added to the RX FIFO and an ACK will be sent in return to the PTX. If the pipe's TX FIFO contains any packets, the next serviceable packet in the TX FIFO will be attached as a payload in the ACK packet. In order for a TX packet to be attached to an ACK, this TX packet would have to be uploaded to the TX FIFO before the packet is received.</p>
<p>PRX cannot ensure that the ACK will always be successfully received by the PTX, the data payload added to the ACK will not be removed from the TX FIFO immediately. This TX packet will be removed from the TX FIFO when a new packet (new packet ID or CRC) is received on the same pipe. In this case, the new packet sent as an ACK will serve as an acknowledgment from the PTX saying that the previous ACK from the PRX was successfully received by the PTX. ACKs sent in reply to retransmission attempts will all contain the same TX payload.</p>
<h1><a class="anchor" id="callback_queuing"></a>
Callback queuing</h1>
<p>ESB contains an internal callback queue for queuing pending callbacks. This allows the application to queue callback functions while the application is already servicing a previously called callback function. In addition, this allows the ESB process to function uninterrupted.</p>
<p>For example, if a new packet is being received while the application is already servicing the <a class="el" href="a01190.html#gab3042dde4c3151c1517f4998378f52ce" title="RX data ready callback.">nrf_esb_rx_data_ready()</a> callback from a previously received packet, the <a class="el" href="a01190.html#gab3042dde4c3151c1517f4998378f52ce" title="RX data ready callback.">nrf_esb_rx_data_ready()</a> callback for the latest packet will be added to the callback queue and serviced at a later opportunity. In this case, <a class="el" href="a01190.html#gab3042dde4c3151c1517f4998378f52ce" title="RX data ready callback.">nrf_esb_rx_data_ready()</a> will be called one time for every received packet, and the application does not need to handle the potential race condition scenario where a new packet is being received just before the application is about to exit the <a class="el" href="a01190.html#gab3042dde4c3151c1517f4998378f52ce" title="RX data ready callback.">nrf_esb_rx_data_ready()</a> function.</p>
<p>Similarly, ESB will call the <a class="el" href="a01190.html#ga416a6ef0fc94e7df9054e71c8784095a" title="TX success callback.">nrf_esb_tx_success()</a> once for every transmitted packet, even when a new packet is being transmitted while the application is servicing the <a class="el" href="a01190.html#ga416a6ef0fc94e7df9054e71c8784095a" title="TX success callback.">nrf_esb_tx_success()</a> callback of a previously transmitted packet.</p>
<p>The callback queue can hold up to 10 pending callback functions. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="a00005.html">User Guides</a></li>
    <li class="footer">Generated on Thu May 7 2015 14:36:28 for nRF51 SDK - S110 SoftDevice by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.3.1 </li>
  </ul>
</div>
</body>
</html>
