<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>nRF51 SDK - S120 SoftDevice: Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="nordic_small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">nRF51 SDK - S120 SoftDevice
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>API&#160;Reference</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a00964.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Functions<div class="ingroups"><a class="el" href="a00749.html">SoC Library API</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga17b2cdfc1c0efb4a25bcc75aeb0c9b9d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00964.html#ga17b2cdfc1c0efb4a25bcc75aeb0c9b9d">sd_mutex_new</a> (<a class="el" href="a00963.html#gaa1ec46ac9de000227852834ec1ff86ea">nrf_mutex_t</a> *p_mutex)</td></tr>
<tr class="memdesc:ga17b2cdfc1c0efb4a25bcc75aeb0c9b9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a mutex.  <a href="#ga17b2cdfc1c0efb4a25bcc75aeb0c9b9d">More...</a><br/></td></tr>
<tr class="separator:ga17b2cdfc1c0efb4a25bcc75aeb0c9b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1407f50bb45705fea4b2bfee5ff01d7"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00964.html#gaa1407f50bb45705fea4b2bfee5ff01d7">sd_mutex_acquire</a> (<a class="el" href="a00963.html#gaa1ec46ac9de000227852834ec1ff86ea">nrf_mutex_t</a> *p_mutex)</td></tr>
<tr class="memdesc:gaa1407f50bb45705fea4b2bfee5ff01d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to acquire a mutex.  <a href="#gaa1407f50bb45705fea4b2bfee5ff01d7">More...</a><br/></td></tr>
<tr class="separator:gaa1407f50bb45705fea4b2bfee5ff01d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaccdf301739ba049b9ec635832120573"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00964.html#gaaccdf301739ba049b9ec635832120573">sd_mutex_release</a> (<a class="el" href="a00963.html#gaa1ec46ac9de000227852834ec1ff86ea">nrf_mutex_t</a> *p_mutex)</td></tr>
<tr class="memdesc:gaaccdf301739ba049b9ec635832120573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a mutex.  <a href="#gaaccdf301739ba049b9ec635832120573">More...</a><br/></td></tr>
<tr class="separator:gaaccdf301739ba049b9ec635832120573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3050ba1fd1707f78b93f4573bf630d52"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00964.html#ga3050ba1fd1707f78b93f4573bf630d52">sd_nvic_EnableIRQ</a> (IRQn_Type IRQn)</td></tr>
<tr class="memdesc:ga3050ba1fd1707f78b93f4573bf630d52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable External Interrupt.  <a href="#ga3050ba1fd1707f78b93f4573bf630d52">More...</a><br/></td></tr>
<tr class="separator:ga3050ba1fd1707f78b93f4573bf630d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c978f0e81b8ee186931d8191f38b925"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00964.html#ga3c978f0e81b8ee186931d8191f38b925">sd_nvic_DisableIRQ</a> (IRQn_Type IRQn)</td></tr>
<tr class="memdesc:ga3c978f0e81b8ee186931d8191f38b925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable External Interrupt.  <a href="#ga3c978f0e81b8ee186931d8191f38b925">More...</a><br/></td></tr>
<tr class="separator:ga3c978f0e81b8ee186931d8191f38b925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf8b97950080aa655f89b90106e23cd0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00964.html#gabf8b97950080aa655f89b90106e23cd0">sd_nvic_GetPendingIRQ</a> (IRQn_Type IRQn, uint32_t *p_pending_irq)</td></tr>
<tr class="memdesc:gabf8b97950080aa655f89b90106e23cd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Pending Interrupt.  <a href="#gabf8b97950080aa655f89b90106e23cd0">More...</a><br/></td></tr>
<tr class="separator:gabf8b97950080aa655f89b90106e23cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a33ae0fa141061aebe36b0f3289c895"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00964.html#ga0a33ae0fa141061aebe36b0f3289c895">sd_nvic_SetPendingIRQ</a> (IRQn_Type IRQn)</td></tr>
<tr class="memdesc:ga0a33ae0fa141061aebe36b0f3289c895"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Pending Interrupt.  <a href="#ga0a33ae0fa141061aebe36b0f3289c895">More...</a><br/></td></tr>
<tr class="separator:ga0a33ae0fa141061aebe36b0f3289c895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace23c47a54b76d98a52b80ce1e3a4516"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00964.html#gace23c47a54b76d98a52b80ce1e3a4516">sd_nvic_ClearPendingIRQ</a> (IRQn_Type IRQn)</td></tr>
<tr class="memdesc:gace23c47a54b76d98a52b80ce1e3a4516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear Pending Interrupt.  <a href="#gace23c47a54b76d98a52b80ce1e3a4516">More...</a><br/></td></tr>
<tr class="separator:gace23c47a54b76d98a52b80ce1e3a4516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga121500074b6b7bb07579a517df15f7a3"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00964.html#ga121500074b6b7bb07579a517df15f7a3">sd_nvic_SetPriority</a> (IRQn_Type IRQn, <a class="el" href="a00963.html#ga2b45edb07b58c30c52475c673d0db856">nrf_app_irq_priority_t</a> priority)</td></tr>
<tr class="memdesc:ga121500074b6b7bb07579a517df15f7a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Interrupt Priority.  <a href="#ga121500074b6b7bb07579a517df15f7a3">More...</a><br/></td></tr>
<tr class="separator:ga121500074b6b7bb07579a517df15f7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a056eb9e18a5151366892c4a3eed543"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00964.html#ga6a056eb9e18a5151366892c4a3eed543">sd_nvic_GetPriority</a> (IRQn_Type IRQn, <a class="el" href="a00963.html#ga2b45edb07b58c30c52475c673d0db856">nrf_app_irq_priority_t</a> *p_priority)</td></tr>
<tr class="memdesc:ga6a056eb9e18a5151366892c4a3eed543"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Interrupt Priority.  <a href="#ga6a056eb9e18a5151366892c4a3eed543">More...</a><br/></td></tr>
<tr class="separator:ga6a056eb9e18a5151366892c4a3eed543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56b098b8840ff629365659821935a81c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00964.html#ga56b098b8840ff629365659821935a81c">sd_nvic_SystemReset</a> (void)</td></tr>
<tr class="memdesc:ga56b098b8840ff629365659821935a81c"><td class="mdescLeft">&#160;</td><td class="mdescRight">System Reset.  <a href="#ga56b098b8840ff629365659821935a81c">More...</a><br/></td></tr>
<tr class="separator:ga56b098b8840ff629365659821935a81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga741284de7360c6be481178191a423d81"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00964.html#ga741284de7360c6be481178191a423d81">sd_nvic_critical_region_enter</a> (uint8_t *p_is_nested_critical_region)</td></tr>
<tr class="memdesc:ga741284de7360c6be481178191a423d81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enters critical region.  <a href="#ga741284de7360c6be481178191a423d81">More...</a><br/></td></tr>
<tr class="separator:ga741284de7360c6be481178191a423d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga608c5d4dd37ff9c46a868c714746065d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00964.html#ga608c5d4dd37ff9c46a868c714746065d">sd_nvic_critical_region_exit</a> (uint8_t is_nested_critical_region)</td></tr>
<tr class="memdesc:ga608c5d4dd37ff9c46a868c714746065d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exit critical region.  <a href="#ga608c5d4dd37ff9c46a868c714746065d">More...</a><br/></td></tr>
<tr class="separator:ga608c5d4dd37ff9c46a868c714746065d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e372c86c718f517174c53a611792489"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00964.html#ga7e372c86c718f517174c53a611792489">sd_rand_application_pool_capacity_get</a> (uint8_t *p_pool_capacity)</td></tr>
<tr class="memdesc:ga7e372c86c718f517174c53a611792489"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the capacity of the application random pool.  <a href="#ga7e372c86c718f517174c53a611792489">More...</a><br/></td></tr>
<tr class="separator:ga7e372c86c718f517174c53a611792489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad12d1ebe6550185897326166e3d4591"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00964.html#gaad12d1ebe6550185897326166e3d4591">sd_rand_application_bytes_available_get</a> (uint8_t *p_bytes_available)</td></tr>
<tr class="memdesc:gaad12d1ebe6550185897326166e3d4591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of random bytes available to the application.  <a href="#gaad12d1ebe6550185897326166e3d4591">More...</a><br/></td></tr>
<tr class="separator:gaad12d1ebe6550185897326166e3d4591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga825412a3746ef587c60d221240691dcd"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00964.html#ga825412a3746ef587c60d221240691dcd">sd_rand_application_vector_get</a> (uint8_t *p_buff, uint8_t length)</td></tr>
<tr class="memdesc:ga825412a3746ef587c60d221240691dcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get random bytes from the application pool.  <a href="#ga825412a3746ef587c60d221240691dcd">More...</a><br/></td></tr>
<tr class="separator:ga825412a3746ef587c60d221240691dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab039839654af96fbcb810b68f4665242"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00964.html#gab039839654af96fbcb810b68f4665242">sd_power_reset_reason_get</a> (uint32_t *p_reset_reason)</td></tr>
<tr class="memdesc:gab039839654af96fbcb810b68f4665242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the reset reason register.  <a href="#gab039839654af96fbcb810b68f4665242">More...</a><br/></td></tr>
<tr class="separator:gab039839654af96fbcb810b68f4665242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35ec66682cd00c0a51c1e8552a285dd2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00964.html#ga35ec66682cd00c0a51c1e8552a285dd2">sd_power_reset_reason_clr</a> (uint32_t reset_reason_clr_msk)</td></tr>
<tr class="memdesc:ga35ec66682cd00c0a51c1e8552a285dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the bits of the reset reason register.  <a href="#ga35ec66682cd00c0a51c1e8552a285dd2">More...</a><br/></td></tr>
<tr class="separator:ga35ec66682cd00c0a51c1e8552a285dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab980a129b83de39c2d7ef7ac33ab6d05"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00964.html#gab980a129b83de39c2d7ef7ac33ab6d05">sd_power_mode_set</a> (<a class="el" href="a00963.html#ga4238ce3ed489f96720efd94ba269ef34">nrf_power_mode_t</a> power_mode)</td></tr>
<tr class="memdesc:gab980a129b83de39c2d7ef7ac33ab6d05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the power mode when in CPU sleep.  <a href="#gab980a129b83de39c2d7ef7ac33ab6d05">More...</a><br/></td></tr>
<tr class="separator:gab980a129b83de39c2d7ef7ac33ab6d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga774947ee0e200456ea3aec3fc7f8bd6b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00964.html#ga774947ee0e200456ea3aec3fc7f8bd6b">sd_power_system_off</a> (void)</td></tr>
<tr class="memdesc:ga774947ee0e200456ea3aec3fc7f8bd6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts the chip in System OFF mode.  <a href="#ga774947ee0e200456ea3aec3fc7f8bd6b">More...</a><br/></td></tr>
<tr class="separator:ga774947ee0e200456ea3aec3fc7f8bd6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac38acbdbcaf059d562e2c600b1acb059"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00964.html#gac38acbdbcaf059d562e2c600b1acb059">sd_power_pof_enable</a> (uint8_t pof_enable)</td></tr>
<tr class="memdesc:gac38acbdbcaf059d562e2c600b1acb059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables the power-fail comparator.  <a href="#gac38acbdbcaf059d562e2c600b1acb059">More...</a><br/></td></tr>
<tr class="separator:gac38acbdbcaf059d562e2c600b1acb059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5670fd45f8c96753df70251a3b4ea1ca"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00964.html#ga5670fd45f8c96753df70251a3b4ea1ca">sd_power_pof_threshold_set</a> (<a class="el" href="a00963.html#gac0c2f5c58e2f930814dcf5b878fe7907">nrf_power_failure_threshold_t</a> threshold)</td></tr>
<tr class="memdesc:ga5670fd45f8c96753df70251a3b4ea1ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the power-fail threshold value.  <a href="#ga5670fd45f8c96753df70251a3b4ea1ca">More...</a><br/></td></tr>
<tr class="separator:ga5670fd45f8c96753df70251a3b4ea1ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e7395f75509209909c47a9dc9fa8a2b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00964.html#ga3e7395f75509209909c47a9dc9fa8a2b">sd_power_ramon_set</a> (uint32_t ramon)</td></tr>
<tr class="memdesc:ga3e7395f75509209909c47a9dc9fa8a2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets bits in the NRF_POWER-&gt;RAMON register.  <a href="#ga3e7395f75509209909c47a9dc9fa8a2b">More...</a><br/></td></tr>
<tr class="separator:ga3e7395f75509209909c47a9dc9fa8a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f2c79002cb2917177cb22b946bb83fb"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00964.html#ga2f2c79002cb2917177cb22b946bb83fb">sd_power_ramon_clr</a> (uint32_t ramon)</td></tr>
<tr class="memdesc:ga2f2c79002cb2917177cb22b946bb83fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears bits in the NRF_POWER-&gt;RAMON register.  <a href="#ga2f2c79002cb2917177cb22b946bb83fb">More...</a><br/></td></tr>
<tr class="separator:ga2f2c79002cb2917177cb22b946bb83fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga086aee62c5d3c605af33b5f445ed46ef"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00964.html#ga086aee62c5d3c605af33b5f445ed46ef">sd_power_ramon_get</a> (uint32_t *p_ramon)</td></tr>
<tr class="memdesc:ga086aee62c5d3c605af33b5f445ed46ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get contents of NRF_POWER-&gt;RAMON register, indicates power status of ram blocks.  <a href="#ga086aee62c5d3c605af33b5f445ed46ef">More...</a><br/></td></tr>
<tr class="separator:ga086aee62c5d3c605af33b5f445ed46ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fde570f484d6daa6478aeb1af93d412"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00964.html#ga6fde570f484d6daa6478aeb1af93d412">sd_power_gpregret_set</a> (uint32_t gpregret_msk)</td></tr>
<tr class="memdesc:ga6fde570f484d6daa6478aeb1af93d412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set bits in the NRF_POWER-&gt;GPREGRET register.  <a href="#ga6fde570f484d6daa6478aeb1af93d412">More...</a><br/></td></tr>
<tr class="separator:ga6fde570f484d6daa6478aeb1af93d412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a8c5f117a956062a0de3efb07e5167a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00964.html#ga7a8c5f117a956062a0de3efb07e5167a">sd_power_gpregret_clr</a> (uint32_t gpregret_msk)</td></tr>
<tr class="memdesc:ga7a8c5f117a956062a0de3efb07e5167a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear bits in the NRF_POWER-&gt;GPREGRET register.  <a href="#ga7a8c5f117a956062a0de3efb07e5167a">More...</a><br/></td></tr>
<tr class="separator:ga7a8c5f117a956062a0de3efb07e5167a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08156c79e367410cf7afc784f6189f31"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00964.html#ga08156c79e367410cf7afc784f6189f31">sd_power_gpregret_get</a> (uint32_t *p_gpregret)</td></tr>
<tr class="memdesc:ga08156c79e367410cf7afc784f6189f31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get contents of the NRF_POWER-&gt;GPREGRET register.  <a href="#ga08156c79e367410cf7afc784f6189f31">More...</a><br/></td></tr>
<tr class="separator:ga08156c79e367410cf7afc784f6189f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34b954aaf40905251036737b716533c8"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00964.html#ga34b954aaf40905251036737b716533c8">sd_power_dcdc_mode_set</a> (<a class="el" href="a00963.html#ga628193e81139bd1f6ae53ca70f638cb0">nrf_power_dcdc_mode_t</a> dcdc_mode)</td></tr>
<tr class="memdesc:ga34b954aaf40905251036737b716533c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the DCDC mode.  <a href="#ga34b954aaf40905251036737b716533c8">More...</a><br/></td></tr>
<tr class="separator:ga34b954aaf40905251036737b716533c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e5afb495a1b0307c749cc268df94a74"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00964.html#ga3e5afb495a1b0307c749cc268df94a74">sd_clock_hfclk_request</a> (void)</td></tr>
<tr class="memdesc:ga3e5afb495a1b0307c749cc268df94a74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request the high frequency crystal oscillator.  <a href="#ga3e5afb495a1b0307c749cc268df94a74">More...</a><br/></td></tr>
<tr class="separator:ga3e5afb495a1b0307c749cc268df94a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7dcec5b896ce32fe70e9b54d7b523f55"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00964.html#ga7dcec5b896ce32fe70e9b54d7b523f55">sd_clock_hfclk_release</a> (void)</td></tr>
<tr class="memdesc:ga7dcec5b896ce32fe70e9b54d7b523f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the high frequency crystal oscillator.  <a href="#ga7dcec5b896ce32fe70e9b54d7b523f55">More...</a><br/></td></tr>
<tr class="separator:ga7dcec5b896ce32fe70e9b54d7b523f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga622439323dd33dbf6de9cf4508478d9e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00964.html#ga622439323dd33dbf6de9cf4508478d9e">sd_clock_hfclk_is_running</a> (uint32_t *p_is_running)</td></tr>
<tr class="memdesc:ga622439323dd33dbf6de9cf4508478d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the high frequency crystal oscillator is running.  <a href="#ga622439323dd33dbf6de9cf4508478d9e">More...</a><br/></td></tr>
<tr class="separator:ga622439323dd33dbf6de9cf4508478d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11d88d38ac99fb72cde74c9385d36433"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00964.html#ga11d88d38ac99fb72cde74c9385d36433">sd_app_evt_wait</a> (void)</td></tr>
<tr class="memdesc:ga11d88d38ac99fb72cde74c9385d36433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for an application event.  <a href="#ga11d88d38ac99fb72cde74c9385d36433">More...</a><br/></td></tr>
<tr class="separator:ga11d88d38ac99fb72cde74c9385d36433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4bca1d649efaf344e264f1896b4e7d3"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00964.html#gaa4bca1d649efaf344e264f1896b4e7d3">sd_ppi_channel_enable_get</a> (uint32_t *p_channel_enable)</td></tr>
<tr class="memdesc:gaa4bca1d649efaf344e264f1896b4e7d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get PPI channel enable register contents.  <a href="#gaa4bca1d649efaf344e264f1896b4e7d3">More...</a><br/></td></tr>
<tr class="separator:gaa4bca1d649efaf344e264f1896b4e7d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa188454bfb10c800a14f21aa29ad84d9"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00964.html#gaa188454bfb10c800a14f21aa29ad84d9">sd_ppi_channel_enable_set</a> (uint32_t channel_enable_set_msk)</td></tr>
<tr class="memdesc:gaa188454bfb10c800a14f21aa29ad84d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set PPI channel enable register.  <a href="#gaa188454bfb10c800a14f21aa29ad84d9">More...</a><br/></td></tr>
<tr class="separator:gaa188454bfb10c800a14f21aa29ad84d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e14d647d82165871f137aa0e659146b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00964.html#ga6e14d647d82165871f137aa0e659146b">sd_ppi_channel_enable_clr</a> (uint32_t channel_enable_clr_msk)</td></tr>
<tr class="memdesc:ga6e14d647d82165871f137aa0e659146b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear PPI channel enable register.  <a href="#ga6e14d647d82165871f137aa0e659146b">More...</a><br/></td></tr>
<tr class="separator:ga6e14d647d82165871f137aa0e659146b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1ca9bfe70cf943a6290516ddceb0a0f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00964.html#gab1ca9bfe70cf943a6290516ddceb0a0f">sd_ppi_channel_assign</a> (uint8_t channel_num, const volatile void *evt_endpoint, const volatile void *task_endpoint)</td></tr>
<tr class="memdesc:gab1ca9bfe70cf943a6290516ddceb0a0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign endpoints to a PPI channel.  <a href="#gab1ca9bfe70cf943a6290516ddceb0a0f">More...</a><br/></td></tr>
<tr class="separator:gab1ca9bfe70cf943a6290516ddceb0a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab42a29d65cf407dbd4bd5f81bc56b897"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00964.html#gab42a29d65cf407dbd4bd5f81bc56b897">sd_ppi_group_task_enable</a> (uint8_t group_num)</td></tr>
<tr class="memdesc:gab42a29d65cf407dbd4bd5f81bc56b897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task to enable a channel group.  <a href="#gab42a29d65cf407dbd4bd5f81bc56b897">More...</a><br/></td></tr>
<tr class="separator:gab42a29d65cf407dbd4bd5f81bc56b897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaea3bb00707d4209992d34bc7d7c2223"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00964.html#gaaea3bb00707d4209992d34bc7d7c2223">sd_ppi_group_task_disable</a> (uint8_t group_num)</td></tr>
<tr class="memdesc:gaaea3bb00707d4209992d34bc7d7c2223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task to disable a channel group.  <a href="#gaaea3bb00707d4209992d34bc7d7c2223">More...</a><br/></td></tr>
<tr class="separator:gaaea3bb00707d4209992d34bc7d7c2223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga178d4a905142c88dc7a8ce3635738313"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00964.html#ga178d4a905142c88dc7a8ce3635738313">sd_ppi_group_assign</a> (uint8_t group_num, uint32_t channel_msk)</td></tr>
<tr class="memdesc:ga178d4a905142c88dc7a8ce3635738313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign PPI channels to a channel group.  <a href="#ga178d4a905142c88dc7a8ce3635738313">More...</a><br/></td></tr>
<tr class="separator:ga178d4a905142c88dc7a8ce3635738313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8c5ad47f11322c53a18e2e662234bc3"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00964.html#gaf8c5ad47f11322c53a18e2e662234bc3">sd_ppi_group_get</a> (uint8_t group_num, uint32_t *p_channel_msk)</td></tr>
<tr class="memdesc:gaf8c5ad47f11322c53a18e2e662234bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the PPI channels of a channel group.  <a href="#gaf8c5ad47f11322c53a18e2e662234bc3">More...</a><br/></td></tr>
<tr class="separator:gaf8c5ad47f11322c53a18e2e662234bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15378609daca09588e620b64555fc2e8"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00964.html#ga15378609daca09588e620b64555fc2e8">sd_radio_notification_cfg_set</a> (<a class="el" href="a00963.html#ga5c9c344840a0eea8419eb8ea1789b8d6">nrf_radio_notification_type_t</a> type, <a class="el" href="a00963.html#ga2be0dce389b0d728a857b178b0f3d7ae">nrf_radio_notification_distance_t</a> distance)</td></tr>
<tr class="memdesc:ga15378609daca09588e620b64555fc2e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the Radio Notification signal.  <a href="#ga15378609daca09588e620b64555fc2e8">More...</a><br/></td></tr>
<tr class="separator:ga15378609daca09588e620b64555fc2e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79280d697e7ba03810c6473b0c7dab87"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00964.html#ga79280d697e7ba03810c6473b0c7dab87">sd_ecb_block_encrypt</a> (<a class="el" href="a00265.html">nrf_ecb_hal_data_t</a> *p_ecb_data)</td></tr>
<tr class="memdesc:ga79280d697e7ba03810c6473b0c7dab87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encrypts a block according to the specified parameters.  <a href="#ga79280d697e7ba03810c6473b0c7dab87">More...</a><br/></td></tr>
<tr class="separator:ga79280d697e7ba03810c6473b0c7dab87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bb3db4bb663fe6deb65f92f1f0cbbcc"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00964.html#ga8bb3db4bb663fe6deb65f92f1f0cbbcc">sd_evt_get</a> (uint32_t *p_evt_id)</td></tr>
<tr class="memdesc:ga8bb3db4bb663fe6deb65f92f1f0cbbcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets any pending events generated by the SoC API.  <a href="#ga8bb3db4bb663fe6deb65f92f1f0cbbcc">More...</a><br/></td></tr>
<tr class="separator:ga8bb3db4bb663fe6deb65f92f1f0cbbcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade0ea69f513ff1feab2c4f6e1c393313"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00964.html#gade0ea69f513ff1feab2c4f6e1c393313">sd_temp_get</a> (int32_t *p_temp)</td></tr>
<tr class="memdesc:gade0ea69f513ff1feab2c4f6e1c393313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the temperature measured on the chip.  <a href="#gade0ea69f513ff1feab2c4f6e1c393313">More...</a><br/></td></tr>
<tr class="separator:gade0ea69f513ff1feab2c4f6e1c393313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b49f2e72e97291aecc18ce396956eed"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00964.html#ga8b49f2e72e97291aecc18ce396956eed">sd_flash_write</a> (uint32_t *const p_dst, uint32_t const *const p_src, uint32_t size)</td></tr>
<tr class="memdesc:ga8b49f2e72e97291aecc18ce396956eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flash Write.  <a href="#ga8b49f2e72e97291aecc18ce396956eed">More...</a><br/></td></tr>
<tr class="separator:ga8b49f2e72e97291aecc18ce396956eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c93dd94a138ad8b5ed3693ea38ffb3e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00964.html#ga9c93dd94a138ad8b5ed3693ea38ffb3e">sd_flash_page_erase</a> (uint32_t page_number)</td></tr>
<tr class="memdesc:ga9c93dd94a138ad8b5ed3693ea38ffb3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flash Erase page.  <a href="#ga9c93dd94a138ad8b5ed3693ea38ffb3e">More...</a><br/></td></tr>
<tr class="separator:ga9c93dd94a138ad8b5ed3693ea38ffb3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga866ca176c419b9fc943657d0f3b213bd"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00964.html#ga866ca176c419b9fc943657d0f3b213bd">sd_flash_protect</a> (uint32_t protenset0, uint32_t protenset1)</td></tr>
<tr class="memdesc:ga866ca176c419b9fc943657d0f3b213bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flash Protection set.  <a href="#ga866ca176c419b9fc943657d0f3b213bd">More...</a><br/></td></tr>
<tr class="separator:ga866ca176c419b9fc943657d0f3b213bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55a52eb4d0491cb7105de6a13eb2b11b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00964.html#ga55a52eb4d0491cb7105de6a13eb2b11b">sd_radio_session_open</a> (<a class="el" href="a00963.html#gaf5319fc8ecbc011eca84a187f0a4da54">nrf_radio_signal_callback_t</a> p_radio_signal_callback)</td></tr>
<tr class="memdesc:ga55a52eb4d0491cb7105de6a13eb2b11b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a session for radio requests.  <a href="#ga55a52eb4d0491cb7105de6a13eb2b11b">More...</a><br/></td></tr>
<tr class="separator:ga55a52eb4d0491cb7105de6a13eb2b11b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcc6027a70aecaaa27e4deec6231f999"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00964.html#gabcc6027a70aecaaa27e4deec6231f999">sd_radio_session_close</a> (void)</td></tr>
<tr class="memdesc:gabcc6027a70aecaaa27e4deec6231f999"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes a session for radio requests.  <a href="#gabcc6027a70aecaaa27e4deec6231f999">More...</a><br/></td></tr>
<tr class="separator:gabcc6027a70aecaaa27e4deec6231f999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga988caf51c5727b9672737da6ee810b28"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00964.html#ga988caf51c5727b9672737da6ee810b28">sd_radio_request</a> (<a class="el" href="a00269.html">nrf_radio_request_t</a> *p_request)</td></tr>
<tr class="memdesc:ga988caf51c5727b9672737da6ee810b28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests a radio timeslot.  <a href="#ga988caf51c5727b9672737da6ee810b28">More...</a><br/></td></tr>
<tr class="separator:ga988caf51c5727b9672737da6ee810b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga11d88d38ac99fb72cde74c9385d36433"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_app_evt_wait </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits for an application event. </p>
<p>An application event is either an application interrupt or a pended interrupt when the interrupt is disabled. When the interrupt is enabled it will be taken immediately since this function will wait in thread mode, then the execution will return in the application's main thread. When an interrupt is disabled and gets pended it will return to the application's thread main. The application must ensure that the pended flag is cleared using <a class="el" href="a00964.html#gace23c47a54b76d98a52b80ce1e3a4516" title="Clear Pending Interrupt.">sd_nvic_ClearPendingIRQ</a> in order to sleep using this function. This is only necessary for disabled interrupts, as the interrupt handler will clear the pending flag automatically for enabled interrupts.</p>
<p>In order to wake up from disabled interrupts, the SEVONPEND flag has to be set in the Cortex-M0 System Control Register (SCR).</p>
<dl class="section see"><dt>See Also</dt><dd>CMSIS_SCB</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If an application interrupt has happened since the last time sd_app_evt_wait was called this function will return immediately and not go to sleep. This is to avoid race conditions that can occur when a flag is updated in the interrupt handler and processed in the main loop.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>An application interrupt has happened or a interrupt pending flag is set.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="a00745.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga622439323dd33dbf6de9cf4508478d9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_clock_hfclk_is_running </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>p_is_running</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the high frequency crystal oscillator is running. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00964.html#ga3e5afb495a1b0307c749cc268df94a74" title="Request the high frequency crystal oscillator.">sd_clock_hfclk_request</a> </dd>
<dd>
<a class="el" href="a00964.html#ga7dcec5b896ce32fe70e9b54d7b523f55" title="Releases the high frequency crystal oscillator.">sd_clock_hfclk_release</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p_is_running</td><td>1 if the external crystal oscillator is running, 0 if not.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="a00745.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7dcec5b896ce32fe70e9b54d7b523f55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_clock_hfclk_release </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases the high frequency crystal oscillator. </p>
<p>Will stop the high frequency crystal oscillator, this happens immediately.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00964.html#ga622439323dd33dbf6de9cf4508478d9e" title="Checks if the high frequency crystal oscillator is running.">sd_clock_hfclk_is_running</a> </dd>
<dd>
<a class="el" href="a00964.html#ga3e5afb495a1b0307c749cc268df94a74" title="Request the high frequency crystal oscillator.">sd_clock_hfclk_request</a></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="a00745.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3e5afb495a1b0307c749cc268df94a74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_clock_hfclk_request </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request the high frequency crystal oscillator. </p>
<p>Will start the high frequency crystal oscillator, the startup time of the crystal varies and the <a class="el" href="a00964.html#ga622439323dd33dbf6de9cf4508478d9e" title="Checks if the high frequency crystal oscillator is running.">sd_clock_hfclk_is_running</a> function can be polled to check if it has started.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00964.html#ga622439323dd33dbf6de9cf4508478d9e" title="Checks if the high frequency crystal oscillator is running.">sd_clock_hfclk_is_running</a> </dd>
<dd>
<a class="el" href="a00964.html#ga7dcec5b896ce32fe70e9b54d7b523f55" title="Releases the high frequency crystal oscillator.">sd_clock_hfclk_release</a></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="a00745.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga79280d697e7ba03810c6473b0c7dab87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ecb_block_encrypt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00265.html">nrf_ecb_hal_data_t</a> *&#160;</td>
          <td class="paramname"><em>p_ecb_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encrypts a block according to the specified parameters. </p>
<p>128-bit AES encryption.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p_ecb_data</td><td>Pointer to the ECB parameters' struct (two input parameters and one output parameter).</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="a00745.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8bb3db4bb663fe6deb65f92f1f0cbbcc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_evt_get </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>p_evt_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets any pending events generated by the SoC API. </p>
<p>The application should keep calling this function to get events, until <a class="el" href="a00745.html#ga349d25ada15be023e0d507f45ada682c" title="Not found.">NRF_ERROR_NOT_FOUND</a> is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p_evt_id</td><td>Set to one of the values in <a class="el" href="a00963.html#ga2a3d2f55035ee3173aff0c05465fb648">NRF_SOC_EVTS</a>, if any events are pending.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="a00745.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td>An event was pending. The event id is written in the p_evt_id parameter. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00745.html#ga349d25ada15be023e0d507f45ada682c" title="Not found.">NRF_ERROR_NOT_FOUND</a></td><td>No pending events. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9c93dd94a138ad8b5ed3693ea38ffb3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_flash_page_erase </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>page_number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flash Erase page. </p>
<p>Commands to erase a flash page If the SoftDevice is enabled: This call initiates the flash access command, and its completion will be communicated to the application with exactly one of the following events:</p>
<ul>
<li><a class="el" href="a00963.html#gga2a3d2f55035ee3173aff0c05465fb648a566ef9d8a97914dd30cd152bdfcd50e6">NRF_EVT_FLASH_OPERATION_SUCCESS</a> - The command was successfully completed.</li>
<li><a class="el" href="a00963.html#gga2a3d2f55035ee3173aff0c05465fb648a7c0083f76ab9ee6e75369776526d584d">NRF_EVT_FLASH_OPERATION_ERROR</a> - The command could not be started.</li>
</ul>
<p>If the SoftDevice is not enabled no event will be generated, and this call will return <a class="el" href="a00745.html#ga7e6367efeaac363d8cf024940b4ec123">NRF_SUCCESS</a> when the erase has been completed</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This call takes control over the radio and the CPU during flash erase and write to make sure that they will not interfere with the flash access. This means that all interrupts will be blocked for a predictable time (depending on the NVMC specification in nRF51 Series Reference Manual and the command parameters).</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">page_number</td><td>Pagenumber of the page to erase </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="a00745.html#gadf8b0c33ea15352808e5ac7f69c2be8a" title="Internal Error.">NRF_ERROR_INTERNAL</a></td><td>If a new session could not be opened due to an internal error. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00745.html#gabc562e4ddfe2f427666a3acdd0b469a3" title="Bad Memory Address.">NRF_ERROR_INVALID_ADDR</a></td><td>Tried to erase to a non existing flash page. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00745.html#ga5d2d8608f6d6a0329f58961a969e946e" title="Busy.">NRF_ERROR_BUSY</a></td><td>The previous command has not yet completed. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00745.html#ga85125dae5d7e9d4b9964acbc13f641b3" title="Forbidden Operation.">NRF_ERROR_FORBIDDEN</a></td><td>Tried to erase a protected page. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00745.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td>The command was accepted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga866ca176c419b9fc943657d0f3b213bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_flash_protect </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>protenset0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>protenset1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flash Protection set. </p>
<p>Commands to set the flash protection registers PROTENSETx</p>
<dl class="section note"><dt>Note</dt><dd>To read the values in PROTENSETx you can read them directly. They are only write-protected.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">protenset0</td><td>Value to be written to PROTENSET0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">protenset1</td><td>Value to be written to PROTENSET1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="a00745.html#ga85125dae5d7e9d4b9964acbc13f641b3" title="Forbidden Operation.">NRF_ERROR_FORBIDDEN</a></td><td>Tried to protect the SoftDevice. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00745.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td>Values successfully written to PROTENSETx. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8b49f2e72e97291aecc18ce396956eed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_flash_write </td>
          <td>(</td>
          <td class="paramtype">uint32_t *const&#160;</td>
          <td class="paramname"><em>p_dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const *const&#160;</td>
          <td class="paramname"><em>p_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flash Write. </p>
<p>Commands to write a buffer to flash</p>
<p>If the SoftDevice is enabled: This call initiates the flash access command, and its completion will be communicated to the application with exactly one of the following events:</p>
<ul>
<li><a class="el" href="a00963.html#gga2a3d2f55035ee3173aff0c05465fb648a566ef9d8a97914dd30cd152bdfcd50e6">NRF_EVT_FLASH_OPERATION_SUCCESS</a> - The command was successfully completed.</li>
<li><a class="el" href="a00963.html#gga2a3d2f55035ee3173aff0c05465fb648a7c0083f76ab9ee6e75369776526d584d">NRF_EVT_FLASH_OPERATION_ERROR</a> - The command could not be started.</li>
</ul>
<p>If the SoftDevice is not enabled no event will be generated, and this call will return <a class="el" href="a00745.html#ga7e6367efeaac363d8cf024940b4ec123">NRF_SUCCESS</a> when the write has been completed</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This call takes control over the radio and the CPU during flash erase and write to make sure that they will not interfere with the flash access. This means that all interrupts will be blocked for a predictable time (depending on the NVMC specification in nRF51 Series Reference Manual and the command parameters).</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_dst</td><td>Pointer to start of flash location to be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_src</td><td>Pointer to buffer with data to be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of 32-bit words to write. Maximum size is 256 32bit words.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="a00745.html#gabc562e4ddfe2f427666a3acdd0b469a3" title="Bad Memory Address.">NRF_ERROR_INVALID_ADDR</a></td><td>Tried to write to a non existing flash address, or p_dst or p_src was unaligned. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00745.html#ga5d2d8608f6d6a0329f58961a969e946e" title="Busy.">NRF_ERROR_BUSY</a></td><td>The previous command has not yet completed. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00745.html#ga59fe2a8fe184005aefa0835c7ff400fd" title="Invalid Length.">NRF_ERROR_INVALID_LENGTH</a></td><td>Size was 0, or more than 256 words. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00745.html#ga85125dae5d7e9d4b9964acbc13f641b3" title="Forbidden Operation.">NRF_ERROR_FORBIDDEN</a></td><td>Tried to write to or read from protected location. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00745.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td>The command was accepted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa1407f50bb45705fea4b2bfee5ff01d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_mutex_acquire </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00963.html#gaa1ec46ac9de000227852834ec1ff86ea">nrf_mutex_t</a> *&#160;</td>
          <td class="paramname"><em>p_mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to acquire a mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_mutex</td><td>Pointer to the mutex to acquire.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="a00745.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td>The mutex was successfully acquired. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00750.html#ga08505c75d1cc68c75b2b529f0acfd9e7" title="Mutex already taken.">NRF_ERROR_SOC_MUTEX_ALREADY_TAKEN</a></td><td>The mutex could not be acquired. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga17b2cdfc1c0efb4a25bcc75aeb0c9b9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_mutex_new </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00963.html#gaa1ec46ac9de000227852834ec1ff86ea">nrf_mutex_t</a> *&#160;</td>
          <td class="paramname"><em>p_mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_mutex</td><td>Pointer to the mutex to initialize.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="a00745.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaaccdf301739ba049b9ec635832120573"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_mutex_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00963.html#gaa1ec46ac9de000227852834ec1ff86ea">nrf_mutex_t</a> *&#160;</td>
          <td class="paramname"><em>p_mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release a mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_mutex</td><td>Pointer to the mutex to release.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="a00745.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gace23c47a54b76d98a52b80ce1e3a4516"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_nvic_ClearPendingIRQ </td>
          <td>(</td>
          <td class="paramtype">IRQn_Type&#160;</td>
          <td class="paramname"><em>IRQn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear Pending Interrupt. </p>
<dl class="section note"><dt>Note</dt><dd>Corresponds to NVIC_ClearPendingIRQ in CMSIS.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>IRQn is valid and not reserved by the stack.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">IRQn</td><td>See the NVIC_ClearPendingIRQ documentation in CMSIS.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="a00745.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td>The interrupt pending flag is cleared. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00750.html#ga4660c0925c76d795707fe77c41aac89b" title="NVIC interrupt not available.">NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE</a></td><td>IRQn is not available for the application. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga741284de7360c6be481178191a423d81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_nvic_critical_region_enter </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>p_is_nested_critical_region</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enters critical region. </p>
<dl class="section post"><dt>Postcondition</dt><dd>Application interrupts will be disabled. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00964.html#ga608c5d4dd37ff9c46a868c714746065d" title="Exit critical region.">sd_nvic_critical_region_exit</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p_is_nested_critical_region</td><td>1: If in a nested critical region. 0: Otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="a00745.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga608c5d4dd37ff9c46a868c714746065d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_nvic_critical_region_exit </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>is_nested_critical_region</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exit critical region. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Application has entered a critical region using <a class="el" href="a00964.html#ga741284de7360c6be481178191a423d81" title="Enters critical region.">sd_nvic_critical_region_enter</a>. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If not in a nested critical region, the application interrupts will restored to the state before <a class="el" href="a00964.html#ga741284de7360c6be481178191a423d81" title="Enters critical region.">sd_nvic_critical_region_enter</a> was called.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">is_nested_critical_region</td><td>If this is set to 1, the critical region won't be exited.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00964.html#ga741284de7360c6be481178191a423d81" title="Enters critical region.">sd_nvic_critical_region_enter</a>.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="a00745.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3c978f0e81b8ee186931d8191f38b925"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_nvic_DisableIRQ </td>
          <td>(</td>
          <td class="paramtype">IRQn_Type&#160;</td>
          <td class="paramname"><em>IRQn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable External Interrupt. </p>
<dl class="section note"><dt>Note</dt><dd>Corresponds to NVIC_DisableIRQ in CMSIS.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>IRQn is valid and not reserved by the stack.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">IRQn</td><td>See the NVIC_DisableIRQ documentation in CMSIS.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="a00745.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td>The interrupt was disabled. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00750.html#ga4660c0925c76d795707fe77c41aac89b" title="NVIC interrupt not available.">NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE</a></td><td>The interrupt is not available for the application. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3050ba1fd1707f78b93f4573bf630d52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_nvic_EnableIRQ </td>
          <td>(</td>
          <td class="paramtype">IRQn_Type&#160;</td>
          <td class="paramname"><em>IRQn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable External Interrupt. </p>
<dl class="section note"><dt>Note</dt><dd>Corresponds to NVIC_EnableIRQ in CMSIS.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>IRQn is valid and not reserved by the stack.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">IRQn</td><td>See the NVIC_EnableIRQ documentation in CMSIS.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="a00745.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td>The interrupt was enabled. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00750.html#ga4660c0925c76d795707fe77c41aac89b" title="NVIC interrupt not available.">NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE</a></td><td>The interrupt is not available for the application. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00750.html#gae2b0d8c5f538bbcab43d82f04412463d" title="NVIC interrupt priority not allowed.">NRF_ERROR_SOC_NVIC_INTERRUPT_PRIORITY_NOT_ALLOWED</a></td><td>The interrupt has a priority not available for the application. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabf8b97950080aa655f89b90106e23cd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_nvic_GetPendingIRQ </td>
          <td>(</td>
          <td class="paramtype">IRQn_Type&#160;</td>
          <td class="paramname"><em>IRQn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>p_pending_irq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Pending Interrupt. </p>
<dl class="section note"><dt>Note</dt><dd>Corresponds to NVIC_GetPendingIRQ in CMSIS.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>IRQn is valid and not reserved by the stack.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">IRQn</td><td>See the NVIC_GetPendingIRQ documentation in CMSIS. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_pending_irq</td><td>Return value from NVIC_GetPendingIRQ.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="a00745.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td>The interrupt is available for the application. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00750.html#ga4660c0925c76d795707fe77c41aac89b" title="NVIC interrupt not available.">NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE</a></td><td>IRQn is not available for the application. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6a056eb9e18a5151366892c4a3eed543"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_nvic_GetPriority </td>
          <td>(</td>
          <td class="paramtype">IRQn_Type&#160;</td>
          <td class="paramname"><em>IRQn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00963.html#ga2b45edb07b58c30c52475c673d0db856">nrf_app_irq_priority_t</a> *&#160;</td>
          <td class="paramname"><em>p_priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Interrupt Priority. </p>
<dl class="section note"><dt>Note</dt><dd>Corresponds to NVIC_GetPriority in CMSIS.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>IRQn is valid and not reserved by the stack.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">IRQn</td><td>See the NVIC_GetPriority documentation in CMSIS. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_priority</td><td>Return value from NVIC_GetPriority.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="a00745.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td>The interrupt priority is returned in p_priority. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00750.html#ga4660c0925c76d795707fe77c41aac89b" title="NVIC interrupt not available.">NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE</a></td><td>- IRQn is not available for the application. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0a33ae0fa141061aebe36b0f3289c895"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_nvic_SetPendingIRQ </td>
          <td>(</td>
          <td class="paramtype">IRQn_Type&#160;</td>
          <td class="paramname"><em>IRQn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set Pending Interrupt. </p>
<dl class="section note"><dt>Note</dt><dd>Corresponds to NVIC_SetPendingIRQ in CMSIS.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>IRQn is valid and not reserved by the stack.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">IRQn</td><td>See the NVIC_SetPendingIRQ documentation in CMSIS.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="a00745.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td>The interrupt is set pending. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00750.html#ga4660c0925c76d795707fe77c41aac89b" title="NVIC interrupt not available.">NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE</a></td><td>IRQn is not available for the application. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga121500074b6b7bb07579a517df15f7a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_nvic_SetPriority </td>
          <td>(</td>
          <td class="paramtype">IRQn_Type&#160;</td>
          <td class="paramname"><em>IRQn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00963.html#ga2b45edb07b58c30c52475c673d0db856">nrf_app_irq_priority_t</a>&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set Interrupt Priority. </p>
<dl class="section note"><dt>Note</dt><dd>Corresponds to NVIC_SetPriority in CMSIS.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>IRQn is valid and not reserved by the stack. </dd>
<dd>
Priority is valid and not reserved by the stack.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">IRQn</td><td>See the NVIC_SetPriority documentation in CMSIS. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">priority</td><td>A valid IRQ priority for use by the application.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="a00745.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td>The interrupt and priority level is available for the application. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00750.html#ga4660c0925c76d795707fe77c41aac89b" title="NVIC interrupt not available.">NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE</a></td><td>IRQn is not available for the application. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00750.html#gae2b0d8c5f538bbcab43d82f04412463d" title="NVIC interrupt priority not allowed.">NRF_ERROR_SOC_NVIC_INTERRUPT_PRIORITY_NOT_ALLOWED</a></td><td>The interrupt priority is not available for the application. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga56b098b8840ff629365659821935a81c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_nvic_SystemReset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>System Reset. </p>
<dl class="section note"><dt>Note</dt><dd>Corresponds to NVIC_SystemReset in CMSIS.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="a00750.html#gadb16c01a8206067f0831b6a7d9cd41c1" title="NVIC should not return.">NRF_ERROR_SOC_NVIC_SHOULD_NOT_RETURN</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga34b954aaf40905251036737b716533c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_power_dcdc_mode_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00963.html#ga628193e81139bd1f6ae53ca70f638cb0">nrf_power_dcdc_mode_t</a>&#160;</td>
          <td class="paramname"><em>dcdc_mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the DCDC mode. </p>
<p>This function is to enable or disable the DCDC periperhal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dcdc_mode</td><td>The mode of the DCDC.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="a00745.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="a00745.html#ga0a5831cf5092e0dd43a01869676ee076" title="Invalid Parameter.">NRF_ERROR_INVALID_PARAM</a></td><td>The DCDC mode is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7a8c5f117a956062a0de3efb07e5167a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_power_gpregret_clr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>gpregret_msk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear bits in the NRF_POWER-&gt;GPREGRET register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gpregret_msk</td><td>Bits to be clear in the GPREGRET register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="a00745.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga08156c79e367410cf7afc784f6189f31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_power_gpregret_get </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>p_gpregret</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get contents of the NRF_POWER-&gt;GPREGRET register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p_gpregret</td><td>Contents of the GPREGRET register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="a00745.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6fde570f484d6daa6478aeb1af93d412"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_power_gpregret_set </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>gpregret_msk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set bits in the NRF_POWER-&gt;GPREGRET register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gpregret_msk</td><td>Bits to be set in the GPREGRET register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="a00745.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab980a129b83de39c2d7ef7ac33ab6d05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_power_mode_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00963.html#ga4238ce3ed489f96720efd94ba269ef34">nrf_power_mode_t</a>&#160;</td>
          <td class="paramname"><em>power_mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the power mode when in CPU sleep. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">power_mode</td><td>The power mode to use when in CPU sleep.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00964.html#ga11d88d38ac99fb72cde74c9385d36433" title="Waits for an application event.">sd_app_evt_wait</a></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="a00745.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td>The power mode was set. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00750.html#gaba78285df6e85daaa153bce5890364df" title="Power mode unknown.">NRF_ERROR_SOC_POWER_MODE_UNKNOWN</a></td><td>The power mode was unknown. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac38acbdbcaf059d562e2c600b1acb059"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_power_pof_enable </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>pof_enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables or disables the power-fail comparator. </p>
<p>Enabling this will give a softdevice event (NRF_EVT_POWER_FAILURE_WARNING) when the power failure warning occurs. The event can be retrieved with <a class="el" href="a00964.html#ga8bb3db4bb663fe6deb65f92f1f0cbbcc" title="Gets any pending events generated by the SoC API.">sd_evt_get()</a>;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pof_enable</td><td>True if the power-fail comparator should be enabled, false if it should be disabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="a00745.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5670fd45f8c96753df70251a3b4ea1ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_power_pof_threshold_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00963.html#gac0c2f5c58e2f930814dcf5b878fe7907">nrf_power_failure_threshold_t</a>&#160;</td>
          <td class="paramname"><em>threshold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the power-fail threshold value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">threshold</td><td>The power-fail threshold value to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="a00745.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td>The power failure threshold was set. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00750.html#ga4c66885f407427c323d19539f6e59e0d" title="Power POF threshold unknown.">NRF_ERROR_SOC_POWER_POF_THRESHOLD_UNKNOWN</a></td><td>The power failure threshold is unknown. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2f2c79002cb2917177cb22b946bb83fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_power_ramon_clr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramon</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears bits in the NRF_POWER-&gt;RAMON register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ramon</td><td>Contains the bits needed to be cleared in the NRF_POWER-&gt;RAMON register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="a00745.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga086aee62c5d3c605af33b5f445ed46ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_power_ramon_get </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>p_ramon</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get contents of NRF_POWER-&gt;RAMON register, indicates power status of ram blocks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p_ramon</td><td>Content of NRF_POWER-&gt;RAMON register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="a00745.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3e7395f75509209909c47a9dc9fa8a2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_power_ramon_set </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ramon</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets bits in the NRF_POWER-&gt;RAMON register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ramon</td><td>Contains the bits needed to be set in the NRF_POWER-&gt;RAMON register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="a00745.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga35ec66682cd00c0a51c1e8552a285dd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_power_reset_reason_clr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>reset_reason_clr_msk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the bits of the reset reason register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">reset_reason_clr_msk</td><td>Contains the bits to clear from the reset reason register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="a00745.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab039839654af96fbcb810b68f4665242"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_power_reset_reason_get </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>p_reset_reason</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the reset reason register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p_reset_reason</td><td>Contents of the NRF_POWER-&gt;RESETREAS register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="a00745.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga774947ee0e200456ea3aec3fc7f8bd6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_power_system_off </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Puts the chip in System OFF mode. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="a00750.html#ga57d53aa15592b0bfacc98d99c4dda07b" title="Power off should not return.">NRF_ERROR_SOC_POWER_OFF_SHOULD_NOT_RETURN</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab1ca9bfe70cf943a6290516ddceb0a0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ppi_channel_assign </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>channel_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const volatile void *&#160;</td>
          <td class="paramname"><em>evt_endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const volatile void *&#160;</td>
          <td class="paramname"><em>task_endpoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign endpoints to a PPI channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">channel_num</td><td>Number of the PPI channel to assign. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">evt_endpoint</td><td>Event endpoint of the PPI channel. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">task_endpoint</td><td>Task endpoint of the PPI channel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="a00750.html#ga563fa0ece398152e3256b09da51fda7f" title="Invalid PPI Channel.">NRF_ERROR_SOC_PPI_INVALID_CHANNEL</a></td><td>The channel number is invalid. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00745.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6e14d647d82165871f137aa0e659146b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ppi_channel_enable_clr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>channel_enable_clr_msk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear PPI channel enable register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">channel_enable_clr_msk</td><td>Mask containing the bits to clear in the PPI CHEN register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="a00745.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa4bca1d649efaf344e264f1896b4e7d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ppi_channel_enable_get </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>p_channel_enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get PPI channel enable register contents. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p_channel_enable</td><td>The contents of the PPI CHEN register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="a00745.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa188454bfb10c800a14f21aa29ad84d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ppi_channel_enable_set </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>channel_enable_set_msk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set PPI channel enable register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">channel_enable_set_msk</td><td>Mask containing the bits to set in the PPI CHEN register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="a00745.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga178d4a905142c88dc7a8ce3635738313"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ppi_group_assign </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>group_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>channel_msk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign PPI channels to a channel group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">group_num</td><td>Number of the channel group. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channel_msk</td><td>Mask of the channels to assign to the group.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="a00750.html#ga78bb614cb480357c7cb191ec8efba5fb" title="Invalid PPI Group.">NRF_ERROR_SOC_PPI_INVALID_GROUP</a></td><td>The group number is invalid. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00745.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf8c5ad47f11322c53a18e2e662234bc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ppi_group_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>group_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>p_channel_msk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the PPI channels of a channel group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">group_num</td><td>Number of the channel group. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_channel_msk</td><td>Mask of the channels assigned to the group.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="a00750.html#ga78bb614cb480357c7cb191ec8efba5fb" title="Invalid PPI Group.">NRF_ERROR_SOC_PPI_INVALID_GROUP</a></td><td>The group number is invalid. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00745.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaaea3bb00707d4209992d34bc7d7c2223"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ppi_group_task_disable </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>group_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Task to disable a channel group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">group_num</td><td>Number of the PPI group.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="a00750.html#ga78bb614cb480357c7cb191ec8efba5fb" title="Invalid PPI Group.">NRF_ERROR_SOC_PPI_INVALID_GROUP</a></td><td>The group number is invalid. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00745.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab42a29d65cf407dbd4bd5f81bc56b897"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ppi_group_task_enable </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>group_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Task to enable a channel group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">group_num</td><td>Number of the channel group.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="a00750.html#ga78bb614cb480357c7cb191ec8efba5fb" title="Invalid PPI Group.">NRF_ERROR_SOC_PPI_INVALID_GROUP</a></td><td>The group number is invalid </td></tr>
    <tr><td class="paramname"><a class="el" href="a00745.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga15378609daca09588e620b64555fc2e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_radio_notification_cfg_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00963.html#ga5c9c344840a0eea8419eb8ea1789b8d6">nrf_radio_notification_type_t</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00963.html#ga2be0dce389b0d728a857b178b0f3d7ae">nrf_radio_notification_distance_t</a>&#160;</td>
          <td class="paramname"><em>distance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the Radio Notification signal. </p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The notification signal latency depends on the interrupt priority settings of SWI used for notification signal.</li>
<li>To ensure that the radio notification signal behaves in a consistent way, always configure radio notifications when there is no protocol stack or other SoftDevice activity in progress. It is recommended that the radio notification signal is configured directly after the SoftDevice has been enabled.</li>
<li>In the period between the ACTIVE signal and the start of the Radio Event, the SoftDevice will interrupt the application to do Radio Event preparation.</li>
<li>Using the Radio Notification feature may limit the bandwidth, as the SoftDevice may have to shorten the connection events to have time for the Radio Notification signals.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Type of notification signal. <a class="el" href="a00963.html#gga20a90837e52ffbde1fb2ad81ef2db8c8ac01e4b09fe151987651c1825c1259276">NRF_RADIO_NOTIFICATION_TYPE_NONE</a> shall be used to turn off radio notification. Using <a class="el" href="a00963.html#gga59b1a77ef6dcb1d75833e5c5f5251d58a8c14977e62861ab59d8d757c084cbac8">NRF_RADIO_NOTIFICATION_DISTANCE_NONE</a> is recommended (but not required) to be used with <a class="el" href="a00963.html#gga20a90837e52ffbde1fb2ad81ef2db8c8ac01e4b09fe151987651c1825c1259276">NRF_RADIO_NOTIFICATION_TYPE_NONE</a>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">distance</td><td>Distance between the notification signal and start of radio activity. This parameter is ignored when <a class="el" href="a00963.html#gga20a90837e52ffbde1fb2ad81ef2db8c8ac01e4b09fe151987651c1825c1259276">NRF_RADIO_NOTIFICATION_TYPE_NONE</a> or <a class="el" href="a00963.html#gga20a90837e52ffbde1fb2ad81ef2db8c8a37db2f7d40ca9532eebff7f8c46b5a86">NRF_RADIO_NOTIFICATION_TYPE_INT_ON_INACTIVE</a> is used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="a00745.html#ga0a5831cf5092e0dd43a01869676ee076" title="Invalid Parameter.">NRF_ERROR_INVALID_PARAM</a></td><td>The group number is invalid. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00745.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga988caf51c5727b9672737da6ee810b28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_radio_request </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00269.html">nrf_radio_request_t</a> *&#160;</td>
          <td class="paramname"><em>p_request</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Requests a radio timeslot. </p>
<dl class="section note"><dt>Note</dt><dd>The request type is determined by p_request-&gt;request_type, and can be one of <a class="el" href="a00963.html#gga1d048df14a3eeef46aabec45e9643858a7951b0d09e47ff7d013fa506890ba42f">NRF_RADIO_REQ_TYPE_EARLIEST</a> and <a class="el" href="a00963.html#gga1d048df14a3eeef46aabec45e9643858a23233e911f0964d33440620f8965497a">NRF_RADIO_REQ_TYPE_NORMAL</a>. The first request in a session must always be of type <a class="el" href="a00963.html#gga1d048df14a3eeef46aabec45e9643858a7951b0d09e47ff7d013fa506890ba42f">NRF_RADIO_REQ_TYPE_EARLIEST</a>. </dd>
<dd>
For a normal request (<a class="el" href="a00963.html#gga1d048df14a3eeef46aabec45e9643858a23233e911f0964d33440620f8965497a">NRF_RADIO_REQ_TYPE_NORMAL</a>), the start time of a radio timeslot is specified by p_request-&gt;distance_us and is given relative to the start of the previous timeslot. </dd>
<dd>
A too small p_request-&gt;distance_us will lead to a <a class="el" href="a00963.html#gga2a3d2f55035ee3173aff0c05465fb648a831ae39db7fcc9e63d66d87029a424d0">NRF_EVT_RADIO_BLOCKED</a> event. </dd>
<dd>
Timeslots scheduled too close will lead to a <a class="el" href="a00963.html#gga2a3d2f55035ee3173aff0c05465fb648a831ae39db7fcc9e63d66d87029a424d0">NRF_EVT_RADIO_BLOCKED</a> event. </dd>
<dd>
See the SoftDevice Specification for more on radio timeslot scheduling, distances and lengths. </dd>
<dd>
If an opportunity for the first radio timeslot is not found before 100ms after the call to this function, it is not scheduled, and instead a <a class="el" href="a00963.html#gga2a3d2f55035ee3173aff0c05465fb648a831ae39db7fcc9e63d66d87029a424d0">NRF_EVT_RADIO_BLOCKED</a> event is sent. The application may then try to schedule the first radio timeslot again. </dd>
<dd>
Successful requests will result in nrf_radio_signal_callback_t(<a class="el" href="a00963.html#gga2ecc6b5725b5075c2fc282d8f5b801b3ac1d8eef43f89255a395eca327086b5f8">NRF_RADIO_CALLBACK_SIGNAL_TYPE_START</a>). Unsuccessful requests will result in a <a class="el" href="a00963.html#gga2a3d2f55035ee3173aff0c05465fb648a831ae39db7fcc9e63d66d87029a424d0">NRF_EVT_RADIO_BLOCKED</a> event, see <a class="el" href="a00963.html#ga2a3d2f55035ee3173aff0c05465fb648">NRF_SOC_EVTS</a>. </dd>
<dd>
The jitter in the start time of the radio timeslots is +/- <a class="el" href="a00962.html#gaee821fbae999c3f4a8429b76ecbdead8">NRF_RADIO_START_JITTER_US</a> us. </dd>
<dd>
The nrf_radio_signal_callback_t(<a class="el" href="a00963.html#gga2ecc6b5725b5075c2fc282d8f5b801b3ac1d8eef43f89255a395eca327086b5f8">NRF_RADIO_CALLBACK_SIGNAL_TYPE_START</a>) call has a latency relative to the specified radio timeslot start, but this does not affect the actual start time of the timeslot. </dd>
<dd>
NRF_TIMER0 is reset at the start of the radio timeslot, and is clocked at 1MHz from the high frequency (16 MHz) clock source. If p_request-&gt;hfclk_force_xtal is true, the high frequency clock is guaranteed to be clocked from the external crystal. </dd>
<dd>
The SoftDevice will neither access the NRF_RADIO peripheral nor the NRF_TIMER0 peripheral during the radio timeslot.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_request</td><td>Pointer to the request parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="a00745.html#ga85125dae5d7e9d4b9964acbc13f641b3" title="Forbidden Operation.">NRF_ERROR_FORBIDDEN</a></td><td>If session not opened or the session is not IDLE. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00745.html#gabc562e4ddfe2f427666a3acdd0b469a3" title="Bad Memory Address.">NRF_ERROR_INVALID_ADDR</a></td><td>If the p_request pointer is invalid. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00745.html#ga0a5831cf5092e0dd43a01869676ee076" title="Invalid Parameter.">NRF_ERROR_INVALID_PARAM</a></td><td>If the parameters of p_request are not valid. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00745.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td>Otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabcc6027a70aecaaa27e4deec6231f999"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_radio_session_close </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes a session for radio requests. </p>
<dl class="section note"><dt>Note</dt><dd>Any current radio timeslot will be finished before the session is closed. </dd>
<dd>
If a radio timeslot is scheduled when the session is closed, it will be canceled. </dd>
<dd>
The application cannot consider the session closed until the <a class="el" href="a00963.html#gga2a3d2f55035ee3173aff0c05465fb648a9ac39a4402cf55b86a44fc3bedd829b1">NRF_EVT_RADIO_SESSION_CLOSED</a> event is received.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="a00745.html#ga85125dae5d7e9d4b9964acbc13f641b3" title="Forbidden Operation.">NRF_ERROR_FORBIDDEN</a></td><td>If session not opened. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00745.html#ga5d2d8608f6d6a0329f58961a969e946e" title="Busy.">NRF_ERROR_BUSY</a></td><td>If session is currently being closed. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00745.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td>Otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga55a52eb4d0491cb7105de6a13eb2b11b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_radio_session_open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00963.html#gaf5319fc8ecbc011eca84a187f0a4da54">nrf_radio_signal_callback_t</a>&#160;</td>
          <td class="paramname"><em>p_radio_signal_callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens a session for radio requests. </p>
<dl class="section note"><dt>Note</dt><dd>Only one session can be open at a time. </dd>
<dd>
p_radio_signal_callback(<a class="el" href="a00963.html#gga2ecc6b5725b5075c2fc282d8f5b801b3ac1d8eef43f89255a395eca327086b5f8">NRF_RADIO_CALLBACK_SIGNAL_TYPE_START</a>) will be called when the radio timeslot starts. From this point the NRF_RADIO and NRF_TIMER0 peripherals can be freely accessed by the application. </dd>
<dd>
p_radio_signal_callback(<a class="el" href="a00963.html#gga2ecc6b5725b5075c2fc282d8f5b801b3a2ce5ff596372a7c8df4bbdd4654be02c">NRF_RADIO_CALLBACK_SIGNAL_TYPE_TIMER0</a>) is called whenever the NRF_TIMER0 interrupt occurs. </dd>
<dd>
p_radio_signal_callback(<a class="el" href="a00963.html#gga2ecc6b5725b5075c2fc282d8f5b801b3a7eedb8b9ee816cd21d1dc3ede51e07ae">NRF_RADIO_CALLBACK_SIGNAL_TYPE_RADIO</a>) is called whenever the NRF_RADIO interrupt occurs. </dd>
<dd>
p_radio_signal_callback() will be called at ARM interrupt priority level 0. This implies that none of the sd_* API calls can be used from p_radio_signal_callback().</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_radio_signal_callback</td><td>The signal callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="a00745.html#gabc562e4ddfe2f427666a3acdd0b469a3" title="Bad Memory Address.">NRF_ERROR_INVALID_ADDR</a></td><td>p_radio_signal_callback is an invalid function pointer. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00745.html#ga5d2d8608f6d6a0329f58961a969e946e" title="Busy.">NRF_ERROR_BUSY</a></td><td>If session cannot be opened. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00745.html#gadf8b0c33ea15352808e5ac7f69c2be8a" title="Internal Error.">NRF_ERROR_INTERNAL</a></td><td>If a new session could not be opened due to an internal error. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00745.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td>Otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaad12d1ebe6550185897326166e3d4591"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_rand_application_bytes_available_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>p_bytes_available</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get number of random bytes available to the application. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p_bytes_available</td><td>The number of bytes currently available in the pool.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="a00745.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7e372c86c718f517174c53a611792489"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_rand_application_pool_capacity_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>p_pool_capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the capacity of the application random pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p_pool_capacity</td><td>The capacity of the pool.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="a00745.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga825412a3746ef587c60d221240691dcd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_rand_application_vector_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>p_buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get random bytes from the application pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p_buff</td><td>Pointer to unit8_t buffer for storing the bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Number of bytes to take from pool and place in p_buff.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="a00745.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td>The requested bytes were written to p_buff. </td></tr>
    <tr><td class="paramname"><a class="el" href="a00750.html#gabb7186c1f08507eecc60e99b569ee2f7" title="RAND not enough values.">NRF_ERROR_SOC_RAND_NOT_ENOUGH_VALUES</a></td><td>No bytes were written to the buffer, because there were not enough bytes available. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gade0ea69f513ff1feab2c4f6e1c393313"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_temp_get </td>
          <td>(</td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>p_temp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the temperature measured on the chip. </p>
<p>This function will block until the temperature measurement is done. It takes around 50us from call to return.</p>
<dl class="section note"><dt>Note</dt><dd>Pan #28 in PAN-028 v 1.6 "Negative measured values are not represented correctly" is corrected by this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p_temp</td><td>Result of temperature measurement. Die temperature in 0.25 degrees celsius.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="a00745.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td>A temperature measurement was done, and the temperature was written to temp </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu May 7 2015 14:36:55 for nRF51 SDK - S120 SoftDevice by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.3.1 </li>
  </ul>
</div>
</body>
</html>
